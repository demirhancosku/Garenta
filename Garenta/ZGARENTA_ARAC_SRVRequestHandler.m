/*
 Auto-Generated by SAP NetWeaver Gateway Productivity Accelerator, Version 1.1.1
 
 File: ZGARENTA_ARAC_SRVRequestHandler.m
 Abstract: A singleton class responsible for sending the appropriate service requests (for retrieving and modifying service data) and parsing the responses into semantic objects, using the ZGARENTA_ARAC_SRV service proxy and the SDMConnectivityHelper class. The sent requests also consider the service URL and the SAP client defined in the application settings. The class is also responsible for sending the appropriate notifications to the application delegate and view controllers, for handling the request success, failure and authentication challenge.  
 
*/
 
#import "ZGARENTA_ARAC_SRVRequestHandler.h"
#import "RequestBuilder.h"
#import "Request.h"
#import "Logger.h"
#import "ErrorHandling.h"
#import "ConnectivitySettings.h"
#import "UsernamePasswordAuthenticator.h"
#import "PortalAuthenticator.h"
#import "CertificateAuthenticator.h"
#import "FormsBasedSAMLAuthenticator.h"
#import "KeychainHelper.h"
#import "SUPHelper.h"
#import "ServiceErrorXmlParser.h"
#import "ServiceErrorJsonParser.h"

#pragma mark - Notifications

//NSString * const kResponseItem = @"item";
//NSString * const kResponseItems = @"items";
//NSString * const kResponseData = @"data";
//NSString * const kRequestedMediaLink = @"mediaLink";
//NSString * const kServerResponseError = @"serverError";
//NSString * const kParsingError = @"parsingError";
//NSString * const kResponseParentItem = @"parent";
//NSString * const kBatchRequest = @"BatchRequest";
//
//// Notification keys:
//NSString * const kAuthenticationNeededNotification = @"AuthenticationNeeded";
static NSString * const kBatchCompletedNotification = @"BatchCompletedNotification";

static NSString * const kRequestUserInfoCompletedNotification = @"requestCompletedNotificaiton";




NSString * const kLoadAvailCarServiceSetCompletedNotification = @"LoadAvailCarServiceSetCompleted";
NSString * const kLoadAvailCarServiceCompletedNotification = @"LoadAvailCarServiceCompleted";
NSString * const kLoadET_ARACLISTESetForAvailCarServiceCompletedNotification = @"LoadET_ARACLISTESetForAvailCarServiceCompleted";
NSString * const kLoadET_EXPIRYSetForAvailCarServiceCompletedNotification = @"LoadET_EXPIRYSetForAvailCarServiceCompleted";
NSString * const kLoadET_FIYATSetForAvailCarServiceCompletedNotification = @"LoadET_FIYATSetForAvailCarServiceCompleted";
NSString * const kLoadET_KAMPANYASetForAvailCarServiceCompletedNotification = @"LoadET_KAMPANYASetForAvailCarServiceCompleted";
NSString * const kLoadET_RESERVSetForAvailCarServiceCompletedNotification = @"LoadET_RESERVSetForAvailCarServiceCompleted";
NSString * const kLoadET_INDIRIMLISTSetForAvailCarServiceCompletedNotification = @"LoadET_INDIRIMLISTSetForAvailCarServiceCompleted";
NSString * const kLoadIMPT_MSUBESetForAvailCarServiceCompletedNotification = @"LoadIMPT_MSUBESetForAvailCarServiceCompleted";
NSString * const kCreateAvailCarServiceCompletedNotification = @"CreateAvailCarServiceCompleted";
NSString * const kUpdateAvailCarServiceCompletedNotification = @"UpdateAvailCarServiceCompleted";
NSString * const kDeleteAvailCarServiceCompletedNotification = @"DeleteAvailCarServiceCompleted";

NSString * const kLoadET_ARACLISTESetCompletedNotification = @"LoadET_ARACLISTESetCompleted";
NSString * const kLoadET_ARACLISTECompletedNotification = @"LoadET_ARACLISTECompleted";
NSString * const kCreateET_ARACLISTECompletedNotification = @"CreateET_ARACLISTECompleted";
NSString * const kUpdateET_ARACLISTECompletedNotification = @"UpdateET_ARACLISTECompleted";
NSString * const kDeleteET_ARACLISTECompletedNotification = @"DeleteET_ARACLISTECompleted";

NSString * const kLoadET_EXPIRYSetCompletedNotification = @"LoadET_EXPIRYSetCompleted";
NSString * const kLoadET_EXPIRYCompletedNotification = @"LoadET_EXPIRYCompleted";
NSString * const kCreateET_EXPIRYCompletedNotification = @"CreateET_EXPIRYCompleted";
NSString * const kUpdateET_EXPIRYCompletedNotification = @"UpdateET_EXPIRYCompleted";
NSString * const kDeleteET_EXPIRYCompletedNotification = @"DeleteET_EXPIRYCompleted";

NSString * const kLoadET_FIYATSetCompletedNotification = @"LoadET_FIYATSetCompleted";
NSString * const kLoadET_FIYATCompletedNotification = @"LoadET_FIYATCompleted";
NSString * const kCreateET_FIYATCompletedNotification = @"CreateET_FIYATCompleted";
NSString * const kUpdateET_FIYATCompletedNotification = @"UpdateET_FIYATCompleted";
NSString * const kDeleteET_FIYATCompletedNotification = @"DeleteET_FIYATCompleted";

NSString * const kLoadET_INDIRIMLISTSetCompletedNotification = @"LoadET_INDIRIMLISTSetCompleted";
NSString * const kLoadET_INDIRIMLISTCompletedNotification = @"LoadET_INDIRIMLISTCompleted";
NSString * const kCreateET_INDIRIMLISTCompletedNotification = @"CreateET_INDIRIMLISTCompleted";
NSString * const kUpdateET_INDIRIMLISTCompletedNotification = @"UpdateET_INDIRIMLISTCompleted";
NSString * const kDeleteET_INDIRIMLISTCompletedNotification = @"DeleteET_INDIRIMLISTCompleted";

NSString * const kLoadET_KAMPANYASetCompletedNotification = @"LoadET_KAMPANYASetCompleted";
NSString * const kLoadET_KAMPANYACompletedNotification = @"LoadET_KAMPANYACompleted";
NSString * const kCreateET_KAMPANYACompletedNotification = @"CreateET_KAMPANYACompleted";
NSString * const kUpdateET_KAMPANYACompletedNotification = @"UpdateET_KAMPANYACompleted";
NSString * const kDeleteET_KAMPANYACompletedNotification = @"DeleteET_KAMPANYACompleted";

NSString * const kLoadET_RESERVSetCompletedNotification = @"LoadET_RESERVSetCompleted";
NSString * const kLoadET_RESERVCompletedNotification = @"LoadET_RESERVCompleted";
NSString * const kCreateET_RESERVCompletedNotification = @"CreateET_RESERVCompleted";
NSString * const kUpdateET_RESERVCompletedNotification = @"UpdateET_RESERVCompleted";
NSString * const kDeleteET_RESERVCompletedNotification = @"DeleteET_RESERVCompleted";

NSString * const kLoadIMPT_MSUBESetCompletedNotification = @"LoadIMPT_MSUBESetCompleted";
NSString * const kLoadIMPT_MSUBECompletedNotification = @"LoadIMPT_MSUBECompleted";
NSString * const kCreateIMPT_MSUBECompletedNotification = @"CreateIMPT_MSUBECompleted";
NSString * const kUpdateIMPT_MSUBECompletedNotification = @"UpdateIMPT_MSUBECompleted";
NSString * const kDeleteIMPT_MSUBECompletedNotification = @"DeleteIMPT_MSUBECompleted";











#pragma mark -

// Service Negotiation constants (used for the service negotiation process):
static NSString * const CatalogServiceUrl = @"/sap/opu/odata/iwfnd/CatalogService/";
static NSString * const TechnicalServiceName = @"";
static NSInteger const TechnicalServiceVersionMin = 0;
static NSInteger const TechnicalServiceVersionMax = 0;

@implementation ZGARENTA_ARAC_SRVRequestHandler

#pragma mark - Initialization

- (id)init
{
    self = [super init];
    if (self) { 
        service = [[ZGARENTA_ARAC_SRVService alloc] init]; // This will be re-initiated with the updated metadata from the server (according to the user locale), in first login. See executeLoginWithUsername:andPassword:error method implementation.
		
        connectivityHelper = [[SDMConnectivityHelper alloc] init];
        connectivityHelper.delegate = self;
        
        self.useServiceNegotiation = YES; // Can be later set to 'NO' to disable service negotiation
        
        deviceLanguage = [NSLocale preferredLanguages][0]; // Language ISO 639 code (2 letters)
    }
    return self;
}

#pragma mark - Singleton

+ (ZGARENTA_ARAC_SRVRequestHandler *)uniqueInstance
{
    static ZGARENTA_ARAC_SRVRequestHandler *instance;
	
    @synchronized(self) {
        if (!instance) {
            instance = [[ZGARENTA_ARAC_SRVRequestHandler alloc] init];
        }
        return instance;
    }
}

#pragma mark - User Login

- (NSData *)executeServiceDocumentRequestAndReturnError:(NSError * __autoreleasing *)error
{
    id<Requesting> serviceDocumentRequest = [connectivityHelper executeBasicSyncRequestWithQuery:[[ODataQuery alloc] initWithURL:[NSURL URLWithString:self.serviceDocumentURL]]];
    
    if ((!serviceDocumentRequest.error) && (serviceDocumentRequest.responseStatusCode == 200) && serviceDocumentRequest.responseData) {
        //Authentication succeeded
        return serviceDocumentRequest.responseData;
    }
    else {
        //Authentication failed
        NSString *errorMessage = NSLocalizedString(@"Login failed.", @"Login failed.");
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:LOGIN_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        LOGERROR(@"Error getting service document. Login failed.");
        return nil;
    }
}

- (NSData *)executeServiceMetadataRequestAndReturnError:(NSError * __autoreleasing *)error
{
    NSString *serviceMetadataUrl = [NSString stringWithFormat:@"%@/$metadata",self.serviceDocumentURL];
    id<Requesting> serviceMetadataRequest = [connectivityHelper executeBasicSyncRequestWithQuery:[[ODataQuery alloc] initWithURL:[NSURL URLWithString:serviceMetadataUrl]]];
    
    if ((!serviceMetadataRequest.error) && (serviceMetadataRequest.responseStatusCode == 200) && serviceMetadataRequest.responseData) {
        //Authentication succeeded
        return serviceMetadataRequest.responseData;
    }
    else {
        //Authentication failed
        NSString *errorMessage = NSLocalizedString(@"Login failed.", @"Login failed.");
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:LOGIN_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        LOGERROR(@"Error getting service metadata. Login failed");
        return nil;
    }
}

- (id <Authenticating>)activateCertificateAuthentication
{
    CertificateAuthenticator *authenticator = [[CertificateAuthenticator alloc] init];
    // The initialized certificate authenticator takes the certificate from the Keychain and exposes it using the following property
    certificate = authenticator.certificate;
    return authenticator;
}

- (id <Authenticating>)activatePortalAuthenticationWithUsername:(NSString *)aUsername andPassword:(NSString *)aPassword
{
    return [[PortalAuthenticator alloc] initWithUsername:aUsername andPassword:aPassword];
}

- (id <Authenticating>)activateUsernamePasswordAuthenticationWithUsername:(NSString *)aUsername andPassword:(NSString *)aPassword
{
    return [[UsernamePasswordAuthenticator alloc] initWithUsername:aUsername andPassword:aPassword];
}

- (id <Authenticating>)activateFormsBasedSAMLAuthenticationWithUsername:(NSString *)aUsername andPassword:(NSString *)aPassword
{
    return [[FormsBasedSAMLAuthenticator alloc] initWithUsername:aUsername andPassword:aPassword];
}

// Initiate the appropriate authenticating implementation according to the Authentication Type configured in the ConnectivitySettings.
- (id <Authenticating>)activateAuthenticationWithUsername:(NSString *)aUsername andPassword:(NSString *)aPassword
{
    id <Authenticating> authenticator;
    // in case in SUP mode, authentication type is defined between SUP Server and Gateway, so we need a simple UsernamePasswordAuthenticator
    if([ConnectivitySettings isSUPMode]) {
        return [[UsernamePasswordAuthenticator alloc] initWithUsername:aUsername andPassword:aPassword];
    }
    else if ([ConnectivitySettings isGWAASMode]) {
        // in case in GWaaS mode, authentication type is defined on the IDP, so we need the FormsBasedSAMLAuthenticator
        return [self activateFormsBasedSAMLAuthenticationWithUsername:aUsername andPassword:aPassword];
    }
    else {
        // in this case we don't use SUP server or GWaaS so we need to define the correct authenticator
        if ([ConnectivitySettings authenticationType] == UsernamePasswordAuthenticationType) {
            authenticator =  [self activateUsernamePasswordAuthenticationWithUsername:aUsername andPassword:aPassword];
        }
        else if ([ConnectivitySettings authenticationType] == PortalAuthenticationType) {
           authenticator =  [self activatePortalAuthenticationWithUsername:aUsername andPassword:aPassword];
        }
        else if ([ConnectivitySettings authenticationType] == CertificateAuthenticationType) {
            authenticator = [self activateCertificateAuthentication];
        }
        else if ([ConnectivitySettings authenticationType] == FormsBasedSAMLAuthenticationType) {
            authenticator = [self activateFormsBasedSAMLAuthenticationWithUsername:aUsername andPassword:aPassword];
        }
    }
    // Set SAP client:
    authenticator.sapClient = self.client; 
    
    return authenticator;
}

- (BOOL)isServiceDocumentURLValidAndReturnError:(NSError * __autoreleasing *)error
{
    if ([self.serviceDocumentURL length] == 0) {
        NSString *errorMessage = NSLocalizedString(@"Service URL is empty.", @"Service URL is empty.");
        if([ConnectivitySettings isSUPMode]) {
            errorMessage = NSLocalizedString(@"Application End Point URL returned from SUP server is empty.", @"Application End Point URL returned from SUP server is empty."); 
        }
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:SERVICE_URL_EMPTY_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        LOGERROR(errorMessage);
        return NO;
    }
    return YES;
}

- (BOOL)setURLAndClientWithSUPApplicationEndPointAndReturnError:(NSError * __autoreleasing *)error
{
    NSString *endPointURL = nil;
    if ([KeychainHelper isCredentialsSaved]){
        CredentialsData *credentials = [KeychainHelper loadCredentialsAndReturnError:error];
        if (credentials) {
            endPointURL = [SUPHelper getSUPApplicationEndPointWithCredentials:credentials error:error];
        }
    }
    
    if ([endPointURL length] == 0) {
        self.serviceDocumentURL = nil;
        self.client = nil;
        NSString *errorMessage = NSLocalizedString(@"Login failed.", @"Login failed.");
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:LOGIN_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        NSString *errorLogMessage = [NSString stringWithFormat:@"Error getting Application End Point URL from SUP server. Login failed. %@.",[*error localizedDescription]];
        LOGERROR(errorLogMessage);
        return NO;
    }
    
    // Extract Base URL and SAP Client from application end point URL:
    
    NSRange range = [endPointURL rangeOfString:@"?"];
    
    if (range.location != NSNotFound) {

        self.serviceDocumentURL = [endPointURL substringToIndex:range.location]; // URL without parameters
        
        // Extract SAP Client parameter:
        NSString *parameters = [endPointURL substringFromIndex:(range.location + range.length)];
        range = [parameters rangeOfString:@"sap-client="];
        NSString *clientValue = nil;
        if (range.location != NSNotFound) {
            
           clientValue = [parameters substringFromIndex:(range.location + range.length)];
            
            // Remove what's after & or / charachters (if exist) from client value
            NSRange range = [clientValue rangeOfString:@"&"];
            if (range.location == NSNotFound) {
               range = [clientValue rangeOfString:@"/"];        
            }
            if (range.location != NSNotFound) {
                clientValue = [clientValue substringToIndex:range.location];
            }
        }
        
        self.client = clientValue;
    }
    else {
        self.serviceDocumentURL = endPointURL;
        self.client = nil;
    }
    
    return YES;
}

- (BOOL)executeLoginWithUsername:(NSString *)aUsername andPassword:(NSString *)aPassword error:(NSError *__autoreleasing *)error
{
    // In case local metadata is used to initiate the service proxy, validate the service before continue with authentication flow
    if (self.useLocalMetadata && ![self isServiceValid]) {
        NSString *errorMessage = NSLocalizedString(@"Service metadata is invalid. Please contact your administrator.", @"Service metadata is invalid. Please contact your administrator.");
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:SERVICE_METADATA_PARSE_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        LOGERROR(errorMessage);
        return NO;
    }
    
    // Activate required authentication type (and set SAP client):
    id <Authenticating> authenticator = [self activateAuthenticationWithUsername:aUsername andPassword:aPassword];
    
    if ([ConnectivitySettings isSUPMode]) {
        // Get application end point from SUP server and use it as a base for the application requests.
        BOOL applicationEndPointReceived = [self setURLAndClientWithSUPApplicationEndPointAndReturnError:error];
        authenticator.sapClient = self.client;
        if (!applicationEndPointReceived) {
            return NO;
        }
    }
    
    // Check that the service URL property was set (from App Delegate or from SUP application end point)
    if (![self isServiceDocumentURLValidAndReturnError:error]) {
        return NO;
    }

    // In case local metadata is used, it's enought to call authenticator to validate credentials without parsing the response
    if (self.useLocalMetadata) {
        // Get service document using the authenticator (negotiation is not supported in this scenario):
        NSData *serviceDocumentData = [authenticator authenticateWithODataQuery:[[ODataQuery alloc] initWithURL:[NSURL URLWithString:self.serviceDocumentURL]] error:error];
        
        if (serviceDocumentData) {
            return YES;
        }
        return NO;
    }
    // In case local metadata is not used, negotiate the best matching service version, get the service data, the service metadata, and re-initialize the service proxy object
    else {
        //Negotiate using the authenticator:
        BOOL serviceNegotiationResult = [self negotiateServiceVersionAndUpdateServiceDocumentUrlUsingAuthenticator:authenticator error:error];
        
        NSData *serviceDocumentData = nil;
        if (serviceNegotiationResult) {
            LOGNOTICE(@"Service negotiation succeeded.");
            // Get service document without authentication (rely on session cookie)
            serviceDocumentData = [self executeServiceDocumentRequestAndReturnError:error];
        }
        else {
            // Get service document using the authenticator:
            serviceDocumentData = [authenticator authenticateWithODataQuery:[[ODataQuery alloc] initWithURL:[NSURL URLWithString:self.serviceDocumentURL]] error:error];
        }
        // Get service metadata and use it to init the service proxy object:
        if (serviceDocumentData) {
            NSData *serviceMetadataData = [self executeServiceMetadataRequestAndReturnError:error];
            if (serviceMetadataData) {
                service = [[ZGARENTA_ARAC_SRVService alloc] initWithServiceDocument:serviceDocumentData andMedatadata:serviceMetadataData];
                [service setServiceDocumentUrl:self.serviceDocumentURL];
                if ([self isServiceValid]) {
                    return YES;
                }
                else {
                    NSString *errorMessage = NSLocalizedString(@"Service metadata is invalid. Please contact your administrator.", @"Service metadata is invalid. Please contact your administrator.");
                    if (error) {
                        *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:SERVICE_METADATA_PARSE_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
                    }
                    LOGERROR(errorMessage);
                    return NO;
                }
            }
        }
        return NO;
    }    
}

- (BOOL)executeLoginWithCertificateWithPassword:(NSString *)aPassword andFileName:(NSString *)aFileName andFileExtension:(NSString *)aFileExtension error:(NSError *__autoreleasing *)error
{
    if ([ConnectivitySettings isSUPMode]) {
        NSString *thePath = [[NSBundle mainBundle]
                             pathForResource:aFileName ofType:aFileExtension];
        if ([thePath length] > 0) {
	        CredentialsData *credentialsData = nil;
            @try {
                credentialsData = [SUPHelper getCredentialsFromCertificateFile:thePath withCertificatePassword:aPassword error:error];
            }
            @catch (NSException* e) {
                NSString *logError = [e description];
                LOGERROR(logError);
            }
	        if (!credentialsData) {
	        	NSString *errorMessage = NSLocalizedString(@"Failed to get certificate string from file", @"Failed to get certificate string from file");
	        	if (error) {
                    if(*error) {
                        NSString *logMessage = [*error localizedDescription];
                        LOGERROR(logMessage);
                    }
                    else {
                        *error = [NSError errorWithDomain:ERROR_DOMAIN code:CERTIFICATE_HANDLING_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
                        LOGERROR(errorMessage);
                    }
                }
                else {
                    LOGERROR(errorMessage);
                }
                return NO;
            }
	        return [self executeLoginWithUsername:credentialsData.username andPassword:credentialsData.password error:error];
        }
        else {
        	NSString *localizedMessage = NSLocalizedString(@"Failed to extract Identity from certificate. Verify that certificate named %@.%@ exists", @"Failed to extract Identity from certificate. Verify that certificate named %@.%@ exists");
        	NSString *errorMessage = [NSString stringWithFormat:localizedMessage, aFileName, aFileExtension];
        	if(error) {
        		*error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:CERTIFICATE_HANDLING_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        	}
        	LOGERROR(errorMessage);
        	return NO;
        }
    }
    return [self executeLoginWithUsername:nil andPassword:nil error:error];
}

- (BOOL)executeLoginWithCertificateWithError:(NSError *__autoreleasing *)error
{
    return [self executeLoginWithCertificateWithPassword:nil andFileName:nil andFileExtension:nil error:error];
}


#pragma mark - Service Negotitation Methods

- (NSData *)executeServiceNegotiationRequestUsingAuthenticator:(id <Authenticating>)authenticator AndReturnError:(NSError * __autoreleasing *)error
{
	NSData *serviceNegotiationResponse = nil;
    NSError *serviceNegotiationError = nil;
	
    ODataQuery *query = [serviceNegotiator getBestMatchingServiceQuery];
	if (query) {
		serviceNegotiationResponse = [authenticator authenticateWithODataQuery:query error:&serviceNegotiationError];
	}
	else {
		return nil;
	}
    
    if (!serviceNegotiationError) {
		return serviceNegotiationResponse;
    }
    else {
        NSString *errorMessage = NSLocalizedString(@"Service negotiation failed.", @"Service negotiation failed.");
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:SERVICE_NEGOTIATION_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        LOGERROR(@"Error getting best matching service. Service negotiation failed.");
        return nil;
    }
}

- (BOOL)negotiateServiceVersionAndUpdateServiceDocumentUrlUsingAuthenticator:(id <Authenticating>)authenticator error:(NSError * __autoreleasing *)error
{
	if (!self.useServiceNegotiation) {
		LOGNOTICE(@"Skipping service negotiation process.");
		return NO;
	}
		
	NSString *catalogServiceUrl = CatalogServiceUrl;
    // If in GWaaS mode then set appropriate catalog service url 
    if ([ConnectivitySettings isGWAASMode]) {
        catalogServiceUrl = @"/CATALOGSERVICE/";
    }
    
	// Initialize service negotiation object
	serviceNegotiator = [[ServiceNegotiator alloc] initWithServiceUrl:self.serviceDocumentURL andCatalogRelativeUrl:catalogServiceUrl];
	
	if (!serviceNegotiator) {
		LOGNOTICE(@"ServiceNegotiator was not initialized. Skipping service negotiation process.");
		return NO;
	}
	
	serviceNegotiator.technicalServiceName = TechnicalServiceName;
	serviceNegotiator.technicalServiceVersionMin = TechnicalServiceVersionMin;
	serviceNegotiator.technicalServiceVersionMax = TechnicalServiceVersionMax;
	
	NSData *serviceData = [self executeServiceNegotiationRequestUsingAuthenticator:authenticator AndReturnError:error];
	
	if (serviceData && [serviceNegotiator parseBestMatchingServiceResultWithData:serviceData]) {
		if (serviceNegotiator.bestMatchingServiceUrl && serviceNegotiator.bestMatchingServiceUrl.length > 0) {
			LOGNOTICE(@"Service negotiation process completed successfully. Updating service document URL.");
			self.serviceDocumentURL = serviceNegotiator.bestMatchingServiceUrl;
            // Make sure the service negotiation process runs only once.
            self.useServiceNegotiation = NO;
            return YES;
		}
	}
	return NO;
}

#pragma mark - Batch

- (void)startBatchWithNotificationName:(NSString *)aNotificationName
{
    [self loadCSRFData];
    
    NSDictionary *userInfoDict = nil;
    if ([aNotificationName length] > 0) {
        userInfoDict = @{kBatchCompletedNotification : aNotificationName};
    }
    [connectivityHelper startBatchAsyncWithURL:[[service.serviceDocumentQuery getUrl] absoluteString] andDelegate:self andSelector:@selector(executeBatchCompleted:) andUserInfo:userInfoDict];
}

- (void)closeExistingChangeSet
{
    [connectivityHelper closeExistingChangeSet];
}

- (void)executeBatch
{
    [connectivityHelper executeBatchAsync:csrfData];
}

- (void)executeBatchCompleted:(BatchRequest *)batchRequest
{
    NSArray *requests = [batchRequest requestArray];
    for (int i = 0; i < [requests count]; i++) {
        if ([requests[i] isKindOfClass:[NSArray class]]) {
            for (Request *request in requests[i]) {
                [self performSelectorOnMainThread:request.didFinishSelector withObject:request waitUntilDone:NO];
            }
        }
        else {
            [self performSelectorOnMainThread:((Request *)requests[i]).didFinishSelector withObject:requests[i] waitUntilDone:NO];
        }
    }
    
    NSDictionary *userInfo = batchRequest.userInfo;
    NSString *notificationName = userInfo[kBatchCompletedNotification];
    if ([notificationName length] > 0) {
        NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:userInfo];
        userInfoDict[kBatchRequest] = batchRequest;
        [[NSNotificationCenter defaultCenter] postNotificationName:notificationName object:self userInfo:userInfoDict];
    }

}

#pragma mark - Instance methods

- (BOOL)isServiceValid
{
    return (service != nil);
}

- (void)setServiceDocumentURL:(NSString *)serviceDocumentURL
{
    _serviceDocumentURL = serviceDocumentURL;
    
    if ([self.serviceDocumentURL length] > 0) {
        [service setServiceDocumentUrl:self.serviceDocumentURL];
    }
}

- (void)setSAPClient:(NSString *)client
{
    _client = client;
    connectivityHelper.sapClient = self.client;
}

- (void)loadCSRFData
{
    if (!csrfData ) {
        csrfData  = [connectivityHelper getCSRFDataForServiceQuery:service.serviceDocumentQuery];
    }
}




#pragma mark - AvailCarServiceSet methods
#pragma mark Read

- (void)loadAvailCarServiceSetCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getAvailCarServiceSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadAvailCarServiceSetCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadAvailCarServiceSet
{
    ODataQuery *query = service.AvailCarServiceSetQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadAvailCarServiceSetCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadAvailCarServiceSetCompleted:) andUserInfo:userInfoDict];
}


- (void)loadAvailCarServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    AvailCarService *item = [AvailCarService parseExpandedAvailCarServiceEntryWithData:request.responseData andServiceDocument:service.sdmServiceDocument error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadAvailCarServiceCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadAvailCarService:(AvailCarService *)aAvailCarService
{
    [self loadAvailCarService:aAvailCarService expand:NO];
}

- (void)loadAvailCarService:(AvailCarService *)aAvailCarService expand:(BOOL)expand
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aAvailCarService.baseUrl];
    if (expand) {
        [query expand:@"ET_ARACLISTESet,ET_EXPIRYSet,ET_FIYATSet,ET_KAMPANYASet,ET_RESERVSet,ET_INDIRIMLISTSet,IMPT_MSUBESet"]; 
    }
    NSDictionary *userInfoDict = @{kResponseParentItem : aAvailCarService , kRequestUserInfoCompletedNotification : kLoadAvailCarServiceCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadAvailCarServiceCompleted:) andUserInfo:userInfoDict];
}

- (void)loadET_ARACLISTESetForAvailCarServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    AvailCarService *parentAvailCarServiceItem = request.userInfo[kResponseParentItem];
    [parentAvailCarServiceItem loadET_ARACLISTESetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentAvailCarServiceItem.ET_ARACLISTESet;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_ARACLISTESetForAvailCarServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadET_ARACLISTESetForAvailCarService:(AvailCarService *)aAvailCarService
{
    ODataQuery *query = aAvailCarService.ET_ARACLISTESetQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aAvailCarService , kRequestUserInfoCompletedNotification : kLoadET_ARACLISTESetForAvailCarServiceCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_ARACLISTESetForAvailCarServiceCompleted:) andUserInfo:userInfoDict];
}

- (void)loadET_EXPIRYSetForAvailCarServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    AvailCarService *parentAvailCarServiceItem = request.userInfo[kResponseParentItem];
    [parentAvailCarServiceItem loadET_EXPIRYSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentAvailCarServiceItem.ET_EXPIRYSet;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_EXPIRYSetForAvailCarServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadET_EXPIRYSetForAvailCarService:(AvailCarService *)aAvailCarService
{
    ODataQuery *query = aAvailCarService.ET_EXPIRYSetQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aAvailCarService , kRequestUserInfoCompletedNotification : kLoadET_EXPIRYSetForAvailCarServiceCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_EXPIRYSetForAvailCarServiceCompleted:) andUserInfo:userInfoDict];
}

- (void)loadET_FIYATSetForAvailCarServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    AvailCarService *parentAvailCarServiceItem = request.userInfo[kResponseParentItem];
    [parentAvailCarServiceItem loadET_FIYATSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentAvailCarServiceItem.ET_FIYATSet;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_FIYATSetForAvailCarServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadET_FIYATSetForAvailCarService:(AvailCarService *)aAvailCarService
{
    ODataQuery *query = aAvailCarService.ET_FIYATSetQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aAvailCarService , kRequestUserInfoCompletedNotification : kLoadET_FIYATSetForAvailCarServiceCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_FIYATSetForAvailCarServiceCompleted:) andUserInfo:userInfoDict];
}

- (void)loadET_KAMPANYASetForAvailCarServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    AvailCarService *parentAvailCarServiceItem = request.userInfo[kResponseParentItem];
    [parentAvailCarServiceItem loadET_KAMPANYASetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentAvailCarServiceItem.ET_KAMPANYASet;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_KAMPANYASetForAvailCarServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadET_KAMPANYASetForAvailCarService:(AvailCarService *)aAvailCarService
{
    ODataQuery *query = aAvailCarService.ET_KAMPANYASetQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aAvailCarService , kRequestUserInfoCompletedNotification : kLoadET_KAMPANYASetForAvailCarServiceCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_KAMPANYASetForAvailCarServiceCompleted:) andUserInfo:userInfoDict];
}

- (void)loadET_RESERVSetForAvailCarServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    AvailCarService *parentAvailCarServiceItem = request.userInfo[kResponseParentItem];
    [parentAvailCarServiceItem loadET_RESERVSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentAvailCarServiceItem.ET_RESERVSet;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_RESERVSetForAvailCarServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadET_RESERVSetForAvailCarService:(AvailCarService *)aAvailCarService
{
    ODataQuery *query = aAvailCarService.ET_RESERVSetQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aAvailCarService , kRequestUserInfoCompletedNotification : kLoadET_RESERVSetForAvailCarServiceCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_RESERVSetForAvailCarServiceCompleted:) andUserInfo:userInfoDict];
}

- (void)loadET_INDIRIMLISTSetForAvailCarServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    AvailCarService *parentAvailCarServiceItem = request.userInfo[kResponseParentItem];
    [parentAvailCarServiceItem loadET_INDIRIMLISTSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentAvailCarServiceItem.ET_INDIRIMLISTSet;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_INDIRIMLISTSetForAvailCarServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadET_INDIRIMLISTSetForAvailCarService:(AvailCarService *)aAvailCarService
{
    ODataQuery *query = aAvailCarService.ET_INDIRIMLISTSetQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aAvailCarService , kRequestUserInfoCompletedNotification : kLoadET_INDIRIMLISTSetForAvailCarServiceCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_INDIRIMLISTSetForAvailCarServiceCompleted:) andUserInfo:userInfoDict];
}

- (void)loadIMPT_MSUBESetForAvailCarServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    AvailCarService *parentAvailCarServiceItem = request.userInfo[kResponseParentItem];
    [parentAvailCarServiceItem loadIMPT_MSUBESetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentAvailCarServiceItem.IMPT_MSUBESet;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadIMPT_MSUBESetForAvailCarServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadIMPT_MSUBESetForAvailCarService:(AvailCarService *)aAvailCarService
{
    ODataQuery *query = aAvailCarService.IMPT_MSUBESetQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aAvailCarService , kRequestUserInfoCompletedNotification : kLoadIMPT_MSUBESetForAvailCarServiceCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadIMPT_MSUBESetForAvailCarServiceCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createAvailCarServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        AvailCarService *item = [AvailCarService parseAvailCarServiceEntryWithData:responseData error:&error];
        item = [AvailCarService parseExpandedAvailCarServiceEntryWithData:responseData andServiceDocument:service.sdmServiceDocument error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateAvailCarServiceCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createAvailCarService:(AvailCarService *)aAvailCarService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aAvailCarService error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aAvailCarService error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateAvailCarServiceCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aAvailCarService , kRequestUserInfoCompletedNotification : kCreateAvailCarServiceCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.AvailCarServiceSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createAvailCarServiceCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createET_ARACLISTE:(ET_ARACLISTE *)aNewET_ARACLISTE forAvailCarService:(AvailCarService *)aAvailCarService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewET_ARACLISTE error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewET_ARACLISTE error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_ARACLISTECompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewET_ARACLISTE , kRequestUserInfoCompletedNotification : kCreateET_ARACLISTECompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aAvailCarService.ET_ARACLISTESetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createET_ARACLISTECompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createET_EXPIRY:(ET_EXPIRY *)aNewET_EXPIRY forAvailCarService:(AvailCarService *)aAvailCarService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewET_EXPIRY error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewET_EXPIRY error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_EXPIRYCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewET_EXPIRY , kRequestUserInfoCompletedNotification : kCreateET_EXPIRYCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aAvailCarService.ET_EXPIRYSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createET_EXPIRYCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createET_FIYAT:(ET_FIYAT *)aNewET_FIYAT forAvailCarService:(AvailCarService *)aAvailCarService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewET_FIYAT error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewET_FIYAT error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_FIYATCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewET_FIYAT , kRequestUserInfoCompletedNotification : kCreateET_FIYATCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aAvailCarService.ET_FIYATSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createET_FIYATCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createET_KAMPANYA:(ET_KAMPANYA *)aNewET_KAMPANYA forAvailCarService:(AvailCarService *)aAvailCarService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewET_KAMPANYA error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewET_KAMPANYA error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_KAMPANYACompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewET_KAMPANYA , kRequestUserInfoCompletedNotification : kCreateET_KAMPANYACompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aAvailCarService.ET_KAMPANYASetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createET_KAMPANYACompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createET_RESERV:(ET_RESERV *)aNewET_RESERV forAvailCarService:(AvailCarService *)aAvailCarService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewET_RESERV error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewET_RESERV error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_RESERVCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewET_RESERV , kRequestUserInfoCompletedNotification : kCreateET_RESERVCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aAvailCarService.ET_RESERVSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createET_RESERVCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createET_INDIRIMLIST:(ET_INDIRIMLIST *)aNewET_INDIRIMLIST forAvailCarService:(AvailCarService *)aAvailCarService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewET_INDIRIMLIST error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewET_INDIRIMLIST error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_INDIRIMLISTCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewET_INDIRIMLIST , kRequestUserInfoCompletedNotification : kCreateET_INDIRIMLISTCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aAvailCarService.ET_INDIRIMLISTSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createET_INDIRIMLISTCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createIMPT_MSUBE:(IMPT_MSUBE *)aNewIMPT_MSUBE forAvailCarService:(AvailCarService *)aAvailCarService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewIMPT_MSUBE error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewIMPT_MSUBE error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIMPT_MSUBECompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewIMPT_MSUBE , kRequestUserInfoCompletedNotification : kCreateIMPT_MSUBECompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aAvailCarService.IMPT_MSUBESetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createIMPT_MSUBECompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateAvailCarServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        AvailCarService *item = [AvailCarService parseAvailCarServiceEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateAvailCarServiceCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateAvailCarService:(AvailCarService *)aAvailCarService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aAvailCarService error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aAvailCarService error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateAvailCarServiceCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aAvailCarService.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aAvailCarService , kRequestUserInfoCompletedNotification : kUpdateAvailCarServiceCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateAvailCarServiceCompleted:) andUserInfo:userInfoDict andEtag:aAvailCarService.etag];
    }
}

#pragma mark Delete

- (void)deleteAvailCarServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteAvailCarServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteAvailCarService:(AvailCarService *)aAvailCarService 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aAvailCarService.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aAvailCarService , kRequestUserInfoCompletedNotification : kDeleteAvailCarServiceCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteAvailCarServiceCompleted:) andUserInfo:userInfoDict andEtag:aAvailCarService.etag];
}

#pragma mark - ET_ARACLISTESet methods
#pragma mark Read

- (void)loadET_ARACLISTESetCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getET_ARACLISTESetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_ARACLISTESetCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadET_ARACLISTESet
{
    ODataQuery *query = service.ET_ARACLISTESetQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadET_ARACLISTESetCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_ARACLISTESetCompleted:) andUserInfo:userInfoDict];
}


- (void)loadET_ARACLISTECompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    ET_ARACLISTE *item = [ET_ARACLISTE parseET_ARACLISTEEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_ARACLISTECompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadET_ARACLISTE:(ET_ARACLISTE *)aET_ARACLISTE
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_ARACLISTE.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aET_ARACLISTE, kRequestUserInfoCompletedNotification : kLoadET_ARACLISTECompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_ARACLISTECompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createET_ARACLISTECompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_ARACLISTE *item = [ET_ARACLISTE parseET_ARACLISTEEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_ARACLISTECompletedNotification object:self userInfo:userInfoDict];

}

- (void)createET_ARACLISTE:(ET_ARACLISTE *)aET_ARACLISTE
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aET_ARACLISTE error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aET_ARACLISTE error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_ARACLISTECompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aET_ARACLISTE , kRequestUserInfoCompletedNotification : kCreateET_ARACLISTECompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.ET_ARACLISTESetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createET_ARACLISTECompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateET_ARACLISTECompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_ARACLISTE *item = [ET_ARACLISTE parseET_ARACLISTEEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_ARACLISTECompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateET_ARACLISTE:(ET_ARACLISTE *)aET_ARACLISTE
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aET_ARACLISTE error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aET_ARACLISTE error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_ARACLISTECompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_ARACLISTE.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aET_ARACLISTE , kRequestUserInfoCompletedNotification : kUpdateET_ARACLISTECompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateET_ARACLISTECompleted:) andUserInfo:userInfoDict andEtag:aET_ARACLISTE.etag];
    }
}

#pragma mark Delete

- (void)deleteET_ARACLISTECompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteET_ARACLISTECompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteET_ARACLISTE:(ET_ARACLISTE *)aET_ARACLISTE 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_ARACLISTE.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aET_ARACLISTE , kRequestUserInfoCompletedNotification : kDeleteET_ARACLISTECompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteET_ARACLISTECompleted:) andUserInfo:userInfoDict andEtag:aET_ARACLISTE.etag];
}

#pragma mark - ET_EXPIRYSet methods
#pragma mark Read

- (void)loadET_EXPIRYSetCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getET_EXPIRYSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_EXPIRYSetCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadET_EXPIRYSet
{
    ODataQuery *query = service.ET_EXPIRYSetQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadET_EXPIRYSetCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_EXPIRYSetCompleted:) andUserInfo:userInfoDict];
}


- (void)loadET_EXPIRYCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    ET_EXPIRY *item = [ET_EXPIRY parseET_EXPIRYEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_EXPIRYCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadET_EXPIRY:(ET_EXPIRY *)aET_EXPIRY
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_EXPIRY.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aET_EXPIRY, kRequestUserInfoCompletedNotification : kLoadET_EXPIRYCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_EXPIRYCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createET_EXPIRYCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_EXPIRY *item = [ET_EXPIRY parseET_EXPIRYEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_EXPIRYCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createET_EXPIRY:(ET_EXPIRY *)aET_EXPIRY
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aET_EXPIRY error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aET_EXPIRY error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_EXPIRYCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aET_EXPIRY , kRequestUserInfoCompletedNotification : kCreateET_EXPIRYCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.ET_EXPIRYSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createET_EXPIRYCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateET_EXPIRYCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_EXPIRY *item = [ET_EXPIRY parseET_EXPIRYEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_EXPIRYCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateET_EXPIRY:(ET_EXPIRY *)aET_EXPIRY
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aET_EXPIRY error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aET_EXPIRY error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_EXPIRYCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_EXPIRY.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aET_EXPIRY , kRequestUserInfoCompletedNotification : kUpdateET_EXPIRYCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateET_EXPIRYCompleted:) andUserInfo:userInfoDict andEtag:aET_EXPIRY.etag];
    }
}

#pragma mark Delete

- (void)deleteET_EXPIRYCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteET_EXPIRYCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteET_EXPIRY:(ET_EXPIRY *)aET_EXPIRY 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_EXPIRY.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aET_EXPIRY , kRequestUserInfoCompletedNotification : kDeleteET_EXPIRYCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteET_EXPIRYCompleted:) andUserInfo:userInfoDict andEtag:aET_EXPIRY.etag];
}

#pragma mark - ET_FIYATSet methods
#pragma mark Read

- (void)loadET_FIYATSetCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getET_FIYATSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_FIYATSetCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadET_FIYATSet
{
    ODataQuery *query = service.ET_FIYATSetQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadET_FIYATSetCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_FIYATSetCompleted:) andUserInfo:userInfoDict];
}


- (void)loadET_FIYATCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    ET_FIYAT *item = [ET_FIYAT parseET_FIYATEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_FIYATCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadET_FIYAT:(ET_FIYAT *)aET_FIYAT
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_FIYAT.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aET_FIYAT, kRequestUserInfoCompletedNotification : kLoadET_FIYATCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_FIYATCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createET_FIYATCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_FIYAT *item = [ET_FIYAT parseET_FIYATEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_FIYATCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createET_FIYAT:(ET_FIYAT *)aET_FIYAT
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aET_FIYAT error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aET_FIYAT error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_FIYATCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aET_FIYAT , kRequestUserInfoCompletedNotification : kCreateET_FIYATCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.ET_FIYATSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createET_FIYATCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateET_FIYATCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_FIYAT *item = [ET_FIYAT parseET_FIYATEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_FIYATCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateET_FIYAT:(ET_FIYAT *)aET_FIYAT
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aET_FIYAT error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aET_FIYAT error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_FIYATCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_FIYAT.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aET_FIYAT , kRequestUserInfoCompletedNotification : kUpdateET_FIYATCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateET_FIYATCompleted:) andUserInfo:userInfoDict andEtag:aET_FIYAT.etag];
    }
}

#pragma mark Delete

- (void)deleteET_FIYATCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteET_FIYATCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteET_FIYAT:(ET_FIYAT *)aET_FIYAT 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_FIYAT.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aET_FIYAT , kRequestUserInfoCompletedNotification : kDeleteET_FIYATCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteET_FIYATCompleted:) andUserInfo:userInfoDict andEtag:aET_FIYAT.etag];
}

#pragma mark - ET_INDIRIMLISTSet methods
#pragma mark Read

- (void)loadET_INDIRIMLISTSetCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getET_INDIRIMLISTSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_INDIRIMLISTSetCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadET_INDIRIMLISTSet
{
    ODataQuery *query = service.ET_INDIRIMLISTSetQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadET_INDIRIMLISTSetCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_INDIRIMLISTSetCompleted:) andUserInfo:userInfoDict];
}


- (void)loadET_INDIRIMLISTCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    ET_INDIRIMLIST *item = [ET_INDIRIMLIST parseET_INDIRIMLISTEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_INDIRIMLISTCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadET_INDIRIMLIST:(ET_INDIRIMLIST *)aET_INDIRIMLIST
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_INDIRIMLIST.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aET_INDIRIMLIST, kRequestUserInfoCompletedNotification : kLoadET_INDIRIMLISTCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_INDIRIMLISTCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createET_INDIRIMLISTCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_INDIRIMLIST *item = [ET_INDIRIMLIST parseET_INDIRIMLISTEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_INDIRIMLISTCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createET_INDIRIMLIST:(ET_INDIRIMLIST *)aET_INDIRIMLIST
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aET_INDIRIMLIST error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aET_INDIRIMLIST error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_INDIRIMLISTCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aET_INDIRIMLIST , kRequestUserInfoCompletedNotification : kCreateET_INDIRIMLISTCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.ET_INDIRIMLISTSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createET_INDIRIMLISTCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateET_INDIRIMLISTCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_INDIRIMLIST *item = [ET_INDIRIMLIST parseET_INDIRIMLISTEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_INDIRIMLISTCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateET_INDIRIMLIST:(ET_INDIRIMLIST *)aET_INDIRIMLIST
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aET_INDIRIMLIST error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aET_INDIRIMLIST error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_INDIRIMLISTCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_INDIRIMLIST.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aET_INDIRIMLIST , kRequestUserInfoCompletedNotification : kUpdateET_INDIRIMLISTCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateET_INDIRIMLISTCompleted:) andUserInfo:userInfoDict andEtag:aET_INDIRIMLIST.etag];
    }
}

#pragma mark Delete

- (void)deleteET_INDIRIMLISTCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteET_INDIRIMLISTCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteET_INDIRIMLIST:(ET_INDIRIMLIST *)aET_INDIRIMLIST 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_INDIRIMLIST.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aET_INDIRIMLIST , kRequestUserInfoCompletedNotification : kDeleteET_INDIRIMLISTCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteET_INDIRIMLISTCompleted:) andUserInfo:userInfoDict andEtag:aET_INDIRIMLIST.etag];
}

#pragma mark - ET_KAMPANYASet methods
#pragma mark Read

- (void)loadET_KAMPANYASetCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getET_KAMPANYASetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_KAMPANYASetCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadET_KAMPANYASet
{
    ODataQuery *query = service.ET_KAMPANYASetQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadET_KAMPANYASetCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_KAMPANYASetCompleted:) andUserInfo:userInfoDict];
}


- (void)loadET_KAMPANYACompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    ET_KAMPANYA *item = [ET_KAMPANYA parseET_KAMPANYAEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_KAMPANYACompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadET_KAMPANYA:(ET_KAMPANYA *)aET_KAMPANYA
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_KAMPANYA.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aET_KAMPANYA, kRequestUserInfoCompletedNotification : kLoadET_KAMPANYACompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_KAMPANYACompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createET_KAMPANYACompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_KAMPANYA *item = [ET_KAMPANYA parseET_KAMPANYAEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_KAMPANYACompletedNotification object:self userInfo:userInfoDict];

}

- (void)createET_KAMPANYA:(ET_KAMPANYA *)aET_KAMPANYA
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aET_KAMPANYA error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aET_KAMPANYA error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_KAMPANYACompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aET_KAMPANYA , kRequestUserInfoCompletedNotification : kCreateET_KAMPANYACompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.ET_KAMPANYASetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createET_KAMPANYACompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateET_KAMPANYACompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_KAMPANYA *item = [ET_KAMPANYA parseET_KAMPANYAEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_KAMPANYACompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateET_KAMPANYA:(ET_KAMPANYA *)aET_KAMPANYA
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aET_KAMPANYA error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aET_KAMPANYA error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_KAMPANYACompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_KAMPANYA.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aET_KAMPANYA , kRequestUserInfoCompletedNotification : kUpdateET_KAMPANYACompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateET_KAMPANYACompleted:) andUserInfo:userInfoDict andEtag:aET_KAMPANYA.etag];
    }
}

#pragma mark Delete

- (void)deleteET_KAMPANYACompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteET_KAMPANYACompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteET_KAMPANYA:(ET_KAMPANYA *)aET_KAMPANYA 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_KAMPANYA.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aET_KAMPANYA , kRequestUserInfoCompletedNotification : kDeleteET_KAMPANYACompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteET_KAMPANYACompleted:) andUserInfo:userInfoDict andEtag:aET_KAMPANYA.etag];
}

#pragma mark - ET_RESERVSet methods
#pragma mark Read

- (void)loadET_RESERVSetCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getET_RESERVSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_RESERVSetCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadET_RESERVSet
{
    ODataQuery *query = service.ET_RESERVSetQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadET_RESERVSetCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_RESERVSetCompleted:) andUserInfo:userInfoDict];
}


- (void)loadET_RESERVCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    ET_RESERV *item = [ET_RESERV parseET_RESERVEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_RESERVCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadET_RESERV:(ET_RESERV *)aET_RESERV
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_RESERV.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aET_RESERV, kRequestUserInfoCompletedNotification : kLoadET_RESERVCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_RESERVCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createET_RESERVCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_RESERV *item = [ET_RESERV parseET_RESERVEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_RESERVCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createET_RESERV:(ET_RESERV *)aET_RESERV
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aET_RESERV error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aET_RESERV error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_RESERVCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aET_RESERV , kRequestUserInfoCompletedNotification : kCreateET_RESERVCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.ET_RESERVSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createET_RESERVCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateET_RESERVCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_RESERV *item = [ET_RESERV parseET_RESERVEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_RESERVCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateET_RESERV:(ET_RESERV *)aET_RESERV
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aET_RESERV error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aET_RESERV error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_RESERVCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_RESERV.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aET_RESERV , kRequestUserInfoCompletedNotification : kUpdateET_RESERVCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateET_RESERVCompleted:) andUserInfo:userInfoDict andEtag:aET_RESERV.etag];
    }
}

#pragma mark Delete

- (void)deleteET_RESERVCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteET_RESERVCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteET_RESERV:(ET_RESERV *)aET_RESERV 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_RESERV.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aET_RESERV , kRequestUserInfoCompletedNotification : kDeleteET_RESERVCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteET_RESERVCompleted:) andUserInfo:userInfoDict andEtag:aET_RESERV.etag];
}

#pragma mark - IMPT_MSUBESet methods
#pragma mark Read

- (void)loadIMPT_MSUBESetCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getIMPT_MSUBESetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadIMPT_MSUBESetCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadIMPT_MSUBESet
{
    ODataQuery *query = service.IMPT_MSUBESetQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadIMPT_MSUBESetCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadIMPT_MSUBESetCompleted:) andUserInfo:userInfoDict];
}


- (void)loadIMPT_MSUBECompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    IMPT_MSUBE *item = [IMPT_MSUBE parseIMPT_MSUBEEntryWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItem] = item;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadIMPT_MSUBECompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadIMPT_MSUBE:(IMPT_MSUBE *)aIMPT_MSUBE
{
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aIMPT_MSUBE.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aIMPT_MSUBE, kRequestUserInfoCompletedNotification : kLoadIMPT_MSUBECompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadIMPT_MSUBECompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createIMPT_MSUBECompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        IMPT_MSUBE *item = [IMPT_MSUBE parseIMPT_MSUBEEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIMPT_MSUBECompletedNotification object:self userInfo:userInfoDict];

}

- (void)createIMPT_MSUBE:(IMPT_MSUBE *)aIMPT_MSUBE
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aIMPT_MSUBE error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aIMPT_MSUBE error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIMPT_MSUBECompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aIMPT_MSUBE , kRequestUserInfoCompletedNotification : kCreateIMPT_MSUBECompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.IMPT_MSUBESetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createIMPT_MSUBECompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateIMPT_MSUBECompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        IMPT_MSUBE *item = [IMPT_MSUBE parseIMPT_MSUBEEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateIMPT_MSUBECompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateIMPT_MSUBE:(IMPT_MSUBE *)aIMPT_MSUBE
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aIMPT_MSUBE error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aIMPT_MSUBE error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateIMPT_MSUBECompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aIMPT_MSUBE.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aIMPT_MSUBE , kRequestUserInfoCompletedNotification : kUpdateIMPT_MSUBECompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateIMPT_MSUBECompleted:) andUserInfo:userInfoDict andEtag:aIMPT_MSUBE.etag];
    }
}

#pragma mark Delete

- (void)deleteIMPT_MSUBECompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteIMPT_MSUBECompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteIMPT_MSUBE:(IMPT_MSUBE *)aIMPT_MSUBE 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aIMPT_MSUBE.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aIMPT_MSUBE , kRequestUserInfoCompletedNotification : kDeleteIMPT_MSUBECompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteIMPT_MSUBECompleted:) andUserInfo:userInfoDict andEtag:aIMPT_MSUBE.etag];
}

#pragma mark - Function Import methods

#pragma mark - RequestDelegate

- (void)requestFailed:(Request *)request
{
    int statusCode = request.responseStatusCode;
    if (statusCode == 401) {
        [self authenticationNeededForRequest:request];
        LOGERROR(@"Request failed with authentication error - response status code 401");
    }
    else {
        NSString *errorMessage;
        NSString *logErrorMessage;
        if (statusCode == 403){
            errorMessage = [request responseString];
            NSString *csrfToken = [request responseHeaders][@"x-csrf-token"];
            if (csrfToken.length > 0 && [csrfToken isEqualToString:@"Required"]) {
            	csrfData = nil;
                NSString *localizedMessage = NSLocalizedString(@"CSRF Token is invalid. Try again to get a new token", @"CSRF Token is invalid. Try again to get a new token");
                errorMessage = [NSString stringWithFormat:@"%@. %@", errorMessage, localizedMessage];
                logErrorMessage = [NSString stringWithFormat:@"Request failed due to invalid CSRF with error: %@. Response status code: %d.", errorMessage, statusCode];
            }
        }
        else {
            errorMessage = request.error ? [request.error localizedDescription] : [request responseStatusMessage];
            logErrorMessage = [NSString stringWithFormat:@"Request failed with error: %@. Response status code: %d.", errorMessage, statusCode];
            
            id<ServiceErrorParsing> serviceErrorParser = nil;
            NSString *contentType = [[[request responseHeaders] objectForKey:@"Content-Type"] lowercaseString];
            if ([contentType isEqualToString:@"application/json"]) {
                serviceErrorParser = [[ServiceErrorJsonParser alloc] initWithErrorData:[request responseData]];
            }
            else {
                serviceErrorParser = [[ServiceErrorXmlParser alloc] initWithErrorData:[request responseData]];
            }
            if ([serviceErrorParser parse]) {
                ServiceError *serviceError = [serviceErrorParser result];
                
                if ([serviceError.innerMessage length] > 0){
                    logErrorMessage = [logErrorMessage stringByAppendingString:[NSString stringWithFormat:@" Service error message: %@ Service error inner message: %@", serviceError.message, serviceError.innerMessage]];
                }
                else{
                    logErrorMessage = [logErrorMessage stringByAppendingString:[NSString stringWithFormat:@" Service response: %@", serviceError.message]];
                }
                
                errorMessage = serviceError.message;
            }
            else
            {
                logErrorMessage = [logErrorMessage stringByAppendingString:[NSString stringWithFormat:@" Response body: %@",[request responseString]]];
            }
        }
        LOGERROR(logErrorMessage);
        
        NSMutableDictionary *errorUserInfoDict = [@{} mutableCopy];
        errorUserInfoDict[NSLocalizedDescriptionKey] = errorMessage;
        NSError *error = [NSError errorWithDomain:ERROR_DOMAIN code:REQUEST_FAILED_ERROR_CODE userInfo:errorUserInfoDict];
        
        NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
        userInfoDict[kServerResponseError] = error;
        
        // Send error notification (handled by all the application views)
        [[NSNotificationCenter defaultCenter] postNotificationName:request.userInfo[kRequestUserInfoCompletedNotification] object:self userInfo:userInfoDict];
    }
}


- (void)authenticationNeededForRequest:(Request *)request
{
    //Cancel request and send notification for displaying the login screen
    [request cancelAuthentication];
    [[NSNotificationCenter defaultCenter] postNotificationName:kAuthenticationNeededNotification object:self userInfo:nil];
}

#pragma mark - SDMConnectivityHelperDelegate

- (void)onBeforeSend:(id <Requesting>)request
{
	request.shouldPresentAuthenticationDialog = YES;
    [request setUsername:[ApplicationProperties getSAPUser]];
    [request setPassword:[ApplicationProperties getSAPPassword]];
        [request setTimeOutSeconds:[ApplicationProperties getTimeout]];
    
    if ([ConnectivitySettings isSUPMode]) {
        if ([KeychainHelper isCredentialsSaved]){
            NSError *error = nil;
            CredentialsData *credentials = [KeychainHelper loadCredentialsAndReturnError:&error];
            if (credentials) {
            }
            else if(error) {
                NSString *msg = [error localizedDescription];
                LOGERROR(msg);
            }
            else {
                NSString *msg = NSLocalizedString(@"Error while loading credentials from keychain", @"Error while loading credentials from keychain");
                LOGERROR(msg);
            }
        }
    }
    else if ([ConnectivitySettings authenticationType] == CertificateAuthenticationType) {
        [request setClientCertificateIdentity:certificate];
    }

    //Define the request language as the device language settings. Uncomment the following line to use the user default language as defined on the server.
    [request addRequestHeader:@"sap-language" value:deviceLanguage];
        
    if (self.useJSON) {
        NSString *jsonUrl = [request.url absoluteString];
        // Don't use jSON to fetch metadata or service document
        if ([self isJSONAllowedForUrl:jsonUrl]) {
            [request addRequestHeader:@"Content-Type" value:@"application/json"];
            [request addRequestHeader:@"Accept" value:@"application/json"];
        }
    }
}

- (BOOL)isJSONAllowedForUrl:(NSString *)jsonUrl
{
    if ([jsonUrl rangeOfString:@"$metadata" options:NSCaseInsensitiveSearch].location == NSNotFound) {
        if (![self.serviceDocumentURL isEqualToString:jsonUrl]) {
            return YES;
        }
    }
    
    return NO;
}

@end
