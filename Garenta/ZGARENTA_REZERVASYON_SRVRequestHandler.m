/*
 Auto-Generated by SAP NetWeaver Gateway Productivity Accelerator, Version 1.1.1
 
 File: ZGARENTA_REZERVASYON_SRVRequestHandler.m
 Abstract: A singleton class responsible for sending the appropriate service requests (for retrieving and modifying service data) and parsing the responses into semantic objects, using the ZGARENTA_REZERVASYON_SRV service proxy and the SDMConnectivityHelper class. The sent requests also consider the service URL and the SAP client defined in the application settings. The class is also responsible for sending the appropriate notifications to the application delegate and view controllers, for handling the request success, failure and authentication challenge.  
 
*/
 
#import "ZGARENTA_REZERVASYON_SRVRequestHandler.h"
#import "RequestBuilder.h"
#import "Request.h"
#import "Logger.h"
#import "ErrorHandling.h"
#import "ConnectivitySettings.h"
#import "UsernamePasswordAuthenticator.h"
#import "PortalAuthenticator.h"
#import "CertificateAuthenticator.h"
#import "FormsBasedSAMLAuthenticator.h"
#import "KeychainHelper.h"
#import "SUPHelper.h"
#import "ServiceErrorXmlParser.h"
#import "ServiceErrorJsonParser.h"

#pragma mark - Notifications

static NSString * const kResponseItem = @"item";
static NSString * const kResponseItems = @"items";
static NSString * const kResponseData = @"data";
static NSString * const kRequestedMediaLink = @"mediaLink";
static NSString * const kServerResponseError = @"serverError";
static NSString * const kParsingError = @"parsingError";
static NSString * const kResponseParentItem = @"parent";
static NSString * const kBatchRequest = @"BatchRequest";

// Notification keys:
static NSString * const kAuthenticationNeededNotification = @"AuthenticationNeeded";
static NSString * const kBatchCompletedNotification = @"BatchCompletedNotification";

static NSString * const kRequestUserInfoCompletedNotification = @"requestCompletedNotificaiton";




NSString * const kLoadReservationServiceCompletedNotification = @"LoadReservationServiceCompleted";
NSString * const kLoadIT_ARACLARSetForReservationServiceCompletedNotification = @"LoadIT_ARACLARSetForReservationServiceCompleted";
NSString * const kLoadIT_EKSURUCUSetForReservationServiceCompletedNotification = @"LoadIT_EKSURUCUSetForReservationServiceCompleted";
NSString * const kLoadIT_ITEMSSetForReservationServiceCompletedNotification = @"LoadIT_ITEMSSetForReservationServiceCompleted";
NSString * const kLoadIT_FATURA_ADRESSetForReservationServiceCompletedNotification = @"LoadIT_FATURA_ADRESSetForReservationServiceCompleted";
NSString * const kLoadET_RETURNSetForReservationServiceCompletedNotification = @"LoadET_RETURNSetForReservationServiceCompleted";
NSString * const kLoadIT_TAHSILATSetForReservationServiceCompletedNotification = @"LoadIT_TAHSILATSetForReservationServiceCompleted";
NSString * const kLoadIT_SDREZERVSetForReservationServiceCompletedNotification = @"LoadIT_SDREZERVSetForReservationServiceCompleted";
NSString * const kCreateReservationServiceCompletedNotification = @"CreateReservationServiceCompleted";
NSString * const kUpdateReservationServiceCompletedNotification = @"UpdateReservationServiceCompleted";
NSString * const kDeleteReservationServiceCompletedNotification = @"DeleteReservationServiceCompleted";

NSString * const kLoadET_KK_RETURNCompletedNotification = @"LoadET_KK_RETURNCompleted";
NSString * const kCreateET_KK_RETURNCompletedNotification = @"CreateET_KK_RETURNCompleted";
NSString * const kUpdateET_KK_RETURNCompletedNotification = @"UpdateET_KK_RETURNCompleted";
NSString * const kDeleteET_KK_RETURNCompletedNotification = @"DeleteET_KK_RETURNCompleted";

NSString * const kLoadET_RETURNCompletedNotification = @"LoadET_RETURNCompleted";
NSString * const kCreateET_RETURNCompletedNotification = @"CreateET_RETURNCompleted";
NSString * const kUpdateET_RETURNCompletedNotification = @"UpdateET_RETURNCompleted";
NSString * const kDeleteET_RETURNCompletedNotification = @"DeleteET_RETURNCompleted";

NSString * const kLoadIT_ARACLARCompletedNotification = @"LoadIT_ARACLARCompleted";
NSString * const kCreateIT_ARACLARCompletedNotification = @"CreateIT_ARACLARCompleted";
NSString * const kUpdateIT_ARACLARCompletedNotification = @"UpdateIT_ARACLARCompleted";
NSString * const kDeleteIT_ARACLARCompletedNotification = @"DeleteIT_ARACLARCompleted";

NSString * const kLoadIT_EKSURUCUCompletedNotification = @"LoadIT_EKSURUCUCompleted";
NSString * const kCreateIT_EKSURUCUCompletedNotification = @"CreateIT_EKSURUCUCompleted";
NSString * const kUpdateIT_EKSURUCUCompletedNotification = @"UpdateIT_EKSURUCUCompleted";
NSString * const kDeleteIT_EKSURUCUCompletedNotification = @"DeleteIT_EKSURUCUCompleted";

NSString * const kLoadIT_FATURA_ADRESCompletedNotification = @"LoadIT_FATURA_ADRESCompleted";
NSString * const kCreateIT_FATURA_ADRESCompletedNotification = @"CreateIT_FATURA_ADRESCompleted";
NSString * const kUpdateIT_FATURA_ADRESCompletedNotification = @"UpdateIT_FATURA_ADRESCompleted";
NSString * const kDeleteIT_FATURA_ADRESCompletedNotification = @"DeleteIT_FATURA_ADRESCompleted";

NSString * const kLoadIT_ITEMSCompletedNotification = @"LoadIT_ITEMSCompleted";
NSString * const kCreateIT_ITEMSCompletedNotification = @"CreateIT_ITEMSCompleted";
NSString * const kUpdateIT_ITEMSCompletedNotification = @"UpdateIT_ITEMSCompleted";
NSString * const kDeleteIT_ITEMSCompletedNotification = @"DeleteIT_ITEMSCompleted";

NSString * const kLoadIT_SDREZERVCompletedNotification = @"LoadIT_SDREZERVCompleted";
NSString * const kCreateIT_SDREZERVCompletedNotification = @"CreateIT_SDREZERVCompleted";
NSString * const kUpdateIT_SDREZERVCompletedNotification = @"UpdateIT_SDREZERVCompleted";
NSString * const kDeleteIT_SDREZERVCompletedNotification = @"DeleteIT_SDREZERVCompleted";

NSString * const kLoadIT_TAHSILATCompletedNotification = @"LoadIT_TAHSILATCompleted";
NSString * const kCreateIT_TAHSILATCompletedNotification = @"CreateIT_TAHSILATCompleted";
NSString * const kUpdateIT_TAHSILATCompletedNotification = @"UpdateIT_TAHSILATCompleted";
NSString * const kDeleteIT_TAHSILATCompletedNotification = @"DeleteIT_TAHSILATCompleted";












#pragma mark -

// Service Negotiation constants (used for the service negotiation process):
static NSString * const CatalogServiceUrl = @"/sap/opu/odata/iwfnd/CatalogService/";
static NSString * const TechnicalServiceName = @"";
static NSInteger const TechnicalServiceVersionMin = 0;
static NSInteger const TechnicalServiceVersionMax = 0;

@implementation ZGARENTA_REZERVASYON_SRVRequestHandler

#pragma mark - Initialization

- (id)init
{
    self = [super init];
    if (self) { 
        service = [[ZGARENTA_REZERVASYON_SRVService alloc] init]; // This will be re-initiated with the updated metadata from the server (according to the user locale), in first login. See executeLoginWithUsername:andPassword:error method implementation.
		
        connectivityHelper = [[SDMConnectivityHelper alloc] init];
        connectivityHelper.delegate = self;
        
        self.useServiceNegotiation = YES; // Can be later set to 'NO' to disable service negotiation
        
        deviceLanguage = [NSLocale preferredLanguages][0]; // Language ISO 639 code (2 letters)
    }
    return self;
}

#pragma mark - Singleton

+ (ZGARENTA_REZERVASYON_SRVRequestHandler *)uniqueInstance
{
    static ZGARENTA_REZERVASYON_SRVRequestHandler *instance;
	
    @synchronized(self) {
        if (!instance) {
            instance = [[ZGARENTA_REZERVASYON_SRVRequestHandler alloc] init];
        }
        return instance;
    }
}

#pragma mark - User Login

- (NSData *)executeServiceDocumentRequestAndReturnError:(NSError * __autoreleasing *)error
{
    id<Requesting> serviceDocumentRequest = [connectivityHelper executeBasicSyncRequestWithQuery:[[ODataQuery alloc] initWithURL:[NSURL URLWithString:self.serviceDocumentURL]]];
    
    if ((!serviceDocumentRequest.error) && (serviceDocumentRequest.responseStatusCode == 200) && serviceDocumentRequest.responseData) {
        //Authentication succeeded
        return serviceDocumentRequest.responseData;
    }
    else {
        //Authentication failed
        NSString *errorMessage = NSLocalizedString(@"Login failed.", @"Login failed.");
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:LOGIN_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        LOGERROR(@"Error getting service document. Login failed.");
        return nil;
    }
}

- (NSData *)executeServiceMetadataRequestAndReturnError:(NSError * __autoreleasing *)error
{
    NSString *serviceMetadataUrl = [NSString stringWithFormat:@"%@/$metadata",self.serviceDocumentURL];
    id<Requesting> serviceMetadataRequest = [connectivityHelper executeBasicSyncRequestWithQuery:[[ODataQuery alloc] initWithURL:[NSURL URLWithString:serviceMetadataUrl]]];
    
    if ((!serviceMetadataRequest.error) && (serviceMetadataRequest.responseStatusCode == 200) && serviceMetadataRequest.responseData) {
        //Authentication succeeded
        return serviceMetadataRequest.responseData;
    }
    else {
        //Authentication failed
        NSString *errorMessage = NSLocalizedString(@"Login failed.", @"Login failed.");
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:LOGIN_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        LOGERROR(@"Error getting service metadata. Login failed");
        return nil;
    }
}

- (id <Authenticating>)activateCertificateAuthentication
{
    CertificateAuthenticator *authenticator = [[CertificateAuthenticator alloc] init];
    // The initialized certificate authenticator takes the certificate from the Keychain and exposes it using the following property
    certificate = authenticator.certificate;
    return authenticator;
}

- (id <Authenticating>)activatePortalAuthenticationWithUsername:(NSString *)aUsername andPassword:(NSString *)aPassword
{
    return [[PortalAuthenticator alloc] initWithUsername:aUsername andPassword:aPassword];
}

- (id <Authenticating>)activateUsernamePasswordAuthenticationWithUsername:(NSString *)aUsername andPassword:(NSString *)aPassword
{
    return [[UsernamePasswordAuthenticator alloc] initWithUsername:aUsername andPassword:aPassword];
}

- (id <Authenticating>)activateFormsBasedSAMLAuthenticationWithUsername:(NSString *)aUsername andPassword:(NSString *)aPassword
{
    return [[FormsBasedSAMLAuthenticator alloc] initWithUsername:aUsername andPassword:aPassword];
}

// Initiate the appropriate authenticating implementation according to the Authentication Type configured in the ConnectivitySettings.
- (id <Authenticating>)activateAuthenticationWithUsername:(NSString *)aUsername andPassword:(NSString *)aPassword
{
    id <Authenticating> authenticator;
    // in case in SUP mode, authentication type is defined between SUP Server and Gateway, so we need a simple UsernamePasswordAuthenticator
    if([ConnectivitySettings isSUPMode]) {
        return [[UsernamePasswordAuthenticator alloc] initWithUsername:aUsername andPassword:aPassword];
    }
    else if ([ConnectivitySettings isGWAASMode]) {
        // in case in GWaaS mode, authentication type is defined on the IDP, so we need the FormsBasedSAMLAuthenticator
        return [self activateFormsBasedSAMLAuthenticationWithUsername:aUsername andPassword:aPassword];
    }
    else {
        // in this case we don't use SUP server or GWaaS so we need to define the correct authenticator
        if ([ConnectivitySettings authenticationType] == UsernamePasswordAuthenticationType) {
            authenticator =  [self activateUsernamePasswordAuthenticationWithUsername:aUsername andPassword:aPassword];
        }
        else if ([ConnectivitySettings authenticationType] == PortalAuthenticationType) {
           authenticator =  [self activatePortalAuthenticationWithUsername:aUsername andPassword:aPassword];
        }
        else if ([ConnectivitySettings authenticationType] == CertificateAuthenticationType) {
            authenticator = [self activateCertificateAuthentication];
        }
        else if ([ConnectivitySettings authenticationType] == FormsBasedSAMLAuthenticationType) {
            authenticator = [self activateFormsBasedSAMLAuthenticationWithUsername:aUsername andPassword:aPassword];
        }
    }
    // Set SAP client:
    authenticator.sapClient = self.client; 
    
    return authenticator;
}

- (BOOL)isServiceDocumentURLValidAndReturnError:(NSError * __autoreleasing *)error
{
    if ([self.serviceDocumentURL length] == 0) {
        NSString *errorMessage = NSLocalizedString(@"Service URL is empty.", @"Service URL is empty.");
        if([ConnectivitySettings isSUPMode]) {
            errorMessage = NSLocalizedString(@"Application End Point URL returned from SUP server is empty.", @"Application End Point URL returned from SUP server is empty."); 
        }
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:SERVICE_URL_EMPTY_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        LOGERROR(errorMessage);
        return NO;
    }
    return YES;
}

- (BOOL)setURLAndClientWithSUPApplicationEndPointAndReturnError:(NSError * __autoreleasing *)error
{
    NSString *endPointURL = nil;
    if ([KeychainHelper isCredentialsSaved]){
        CredentialsData *credentials = [KeychainHelper loadCredentialsAndReturnError:error];
        if (credentials) {
            endPointURL = [SUPHelper getSUPApplicationEndPointWithCredentials:credentials error:error];
        }
    }
    
    if ([endPointURL length] == 0) {
        self.serviceDocumentURL = nil;
        self.client = nil;
        NSString *errorMessage = NSLocalizedString(@"Login failed.", @"Login failed.");
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:LOGIN_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        NSString *errorLogMessage = [NSString stringWithFormat:@"Error getting Application End Point URL from SUP server. Login failed. %@.",[*error localizedDescription]];
        LOGERROR(errorLogMessage);
        return NO;
    }
    
    // Extract Base URL and SAP Client from application end point URL:
    
    NSRange range = [endPointURL rangeOfString:@"?"];
    
    if (range.location != NSNotFound) {

        self.serviceDocumentURL = [endPointURL substringToIndex:range.location]; // URL without parameters
        
        // Extract SAP Client parameter:
        NSString *parameters = [endPointURL substringFromIndex:(range.location + range.length)];
        range = [parameters rangeOfString:@"sap-client="];
        NSString *clientValue = nil;
        if (range.location != NSNotFound) {
            
           clientValue = [parameters substringFromIndex:(range.location + range.length)];
            
            // Remove what's after & or / charachters (if exist) from client value
            NSRange range = [clientValue rangeOfString:@"&"];
            if (range.location == NSNotFound) {
               range = [clientValue rangeOfString:@"/"];        
            }
            if (range.location != NSNotFound) {
                clientValue = [clientValue substringToIndex:range.location];
            }
        }
        
        self.client = clientValue;
    }
    else {
        self.serviceDocumentURL = endPointURL;
        self.client = nil;
    }
    
    return YES;
}

- (BOOL)executeLoginWithUsername:(NSString *)aUsername andPassword:(NSString *)aPassword error:(NSError *__autoreleasing *)error
{
    // In case local metadata is used to initiate the service proxy, validate the service before continue with authentication flow
    if (self.useLocalMetadata && ![self isServiceValid]) {
        NSString *errorMessage = NSLocalizedString(@"Service metadata is invalid. Please contact your administrator.", @"Service metadata is invalid. Please contact your administrator.");
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:SERVICE_METADATA_PARSE_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        LOGERROR(errorMessage);
        return NO;
    }
    
    // Activate required authentication type (and set SAP client):
    id <Authenticating> authenticator = [self activateAuthenticationWithUsername:aUsername andPassword:aPassword];
    
    if ([ConnectivitySettings isSUPMode]) {
        // Get application end point from SUP server and use it as a base for the application requests.
        BOOL applicationEndPointReceived = [self setURLAndClientWithSUPApplicationEndPointAndReturnError:error];
        authenticator.sapClient = self.client;
        if (!applicationEndPointReceived) {
            return NO;
        }
    }
    
    // Check that the service URL property was set (from App Delegate or from SUP application end point)
    if (![self isServiceDocumentURLValidAndReturnError:error]) {
        return NO;
    }

    // In case local metadata is used, it's enought to call authenticator to validate credentials without parsing the response
    if (self.useLocalMetadata) {
        // Get service document using the authenticator (negotiation is not supported in this scenario):
        NSData *serviceDocumentData = [authenticator authenticateWithODataQuery:[[ODataQuery alloc] initWithURL:[NSURL URLWithString:self.serviceDocumentURL]] error:error];
        
        if (serviceDocumentData) {
            return YES;
        }
        return NO;
    }
    // In case local metadata is not used, negotiate the best matching service version, get the service data, the service metadata, and re-initialize the service proxy object
    else {
        //Negotiate using the authenticator:
        BOOL serviceNegotiationResult = [self negotiateServiceVersionAndUpdateServiceDocumentUrlUsingAuthenticator:authenticator error:error];
        
        NSData *serviceDocumentData = nil;
        if (serviceNegotiationResult) {
            LOGNOTICE(@"Service negotiation succeeded.");
            // Get service document without authentication (rely on session cookie)
            serviceDocumentData = [self executeServiceDocumentRequestAndReturnError:error];
        }
        else {
            // Get service document using the authenticator:
            serviceDocumentData = [authenticator authenticateWithODataQuery:[[ODataQuery alloc] initWithURL:[NSURL URLWithString:self.serviceDocumentURL]] error:error];
        }
        // Get service metadata and use it to init the service proxy object:
        if (serviceDocumentData) {
            NSData *serviceMetadataData = [self executeServiceMetadataRequestAndReturnError:error];
            if (serviceMetadataData) {
                service = [[ZGARENTA_REZERVASYON_SRVService alloc] initWithServiceDocument:serviceDocumentData andMedatadata:serviceMetadataData];
                [service setServiceDocumentUrl:self.serviceDocumentURL];
                if ([self isServiceValid]) {
                    return YES;
                }
                else {
                    NSString *errorMessage = NSLocalizedString(@"Service metadata is invalid. Please contact your administrator.", @"Service metadata is invalid. Please contact your administrator.");
                    if (error) {
                        *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:SERVICE_METADATA_PARSE_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
                    }
                    LOGERROR(errorMessage);
                    return NO;
                }
            }
        }
        return NO;
    }    
}

- (BOOL)executeLoginWithCertificateWithPassword:(NSString *)aPassword andFileName:(NSString *)aFileName andFileExtension:(NSString *)aFileExtension error:(NSError *__autoreleasing *)error
{
    if ([ConnectivitySettings isSUPMode]) {
        NSString *thePath = [[NSBundle mainBundle]
                             pathForResource:aFileName ofType:aFileExtension];
        if ([thePath length] > 0) {
	        CredentialsData *credentialsData = nil;
            @try {
                credentialsData = [SUPHelper getCredentialsFromCertificateFile:thePath withCertificatePassword:aPassword error:error];
            }
            @catch (NSException* e) {
                NSString *logError = [e description];
                LOGERROR(logError);
            }
	        if (!credentialsData) {
	        	NSString *errorMessage = NSLocalizedString(@"Failed to get certificate string from file", @"Failed to get certificate string from file");
	        	if (error) {
                    if(*error) {
                        NSString *logMessage = [*error localizedDescription];
                        LOGERROR(logMessage);
                    }
                    else {
                        *error = [NSError errorWithDomain:ERROR_DOMAIN code:CERTIFICATE_HANDLING_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
                        LOGERROR(errorMessage);
                    }
                }
                else {
                    LOGERROR(errorMessage);
                }
                return NO;
            }
	        return [self executeLoginWithUsername:credentialsData.username andPassword:credentialsData.password error:error];
        }
        else {
        	NSString *localizedMessage = NSLocalizedString(@"Failed to extract Identity from certificate. Verify that certificate named %@.%@ exists", @"Failed to extract Identity from certificate. Verify that certificate named %@.%@ exists");
        	NSString *errorMessage = [NSString stringWithFormat:localizedMessage, aFileName, aFileExtension];
        	if(error) {
        		*error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:CERTIFICATE_HANDLING_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        	}
        	LOGERROR(errorMessage);
        	return NO;
        }
    }
    return [self executeLoginWithUsername:nil andPassword:nil error:error];
}

- (BOOL)executeLoginWithCertificateWithError:(NSError *__autoreleasing *)error
{
    return [self executeLoginWithCertificateWithPassword:nil andFileName:nil andFileExtension:nil error:error];
}


#pragma mark - Service Negotitation Methods

- (NSData *)executeServiceNegotiationRequestUsingAuthenticator:(id <Authenticating>)authenticator AndReturnError:(NSError * __autoreleasing *)error
{
	NSData *serviceNegotiationResponse = nil;
    NSError *serviceNegotiationError = nil;
	
    ODataQuery *query = [serviceNegotiator getBestMatchingServiceQuery];
	if (query) {
		serviceNegotiationResponse = [authenticator authenticateWithODataQuery:query error:&serviceNegotiationError];
	}
	else {
		return nil;
	}
    
    if (!serviceNegotiationError) {
		return serviceNegotiationResponse;
    }
    else {
        NSString *errorMessage = NSLocalizedString(@"Service negotiation failed.", @"Service negotiation failed.");
        if (error) {
            *error = [[NSError alloc] initWithDomain:ERROR_DOMAIN code:SERVICE_NEGOTIATION_ERROR_CODE userInfo:@{NSLocalizedDescriptionKey: errorMessage}];
        }
        LOGERROR(@"Error getting best matching service. Service negotiation failed.");
        return nil;
    }
}

- (BOOL)negotiateServiceVersionAndUpdateServiceDocumentUrlUsingAuthenticator:(id <Authenticating>)authenticator error:(NSError * __autoreleasing *)error
{
	if (!self.useServiceNegotiation) {
		LOGNOTICE(@"Skipping service negotiation process.");
		return NO;
	}
		
	NSString *catalogServiceUrl = CatalogServiceUrl;
    // If in GWaaS mode then set appropriate catalog service url 
    if ([ConnectivitySettings isGWAASMode]) {
        catalogServiceUrl = @"/CATALOGSERVICE/";
    }
    
	// Initialize service negotiation object
	serviceNegotiator = [[ServiceNegotiator alloc] initWithServiceUrl:self.serviceDocumentURL andCatalogRelativeUrl:catalogServiceUrl];
	
	if (!serviceNegotiator) {
		LOGNOTICE(@"ServiceNegotiator was not initialized. Skipping service negotiation process.");
		return NO;
	}
	
	serviceNegotiator.technicalServiceName = TechnicalServiceName;
	serviceNegotiator.technicalServiceVersionMin = TechnicalServiceVersionMin;
	serviceNegotiator.technicalServiceVersionMax = TechnicalServiceVersionMax;
	
	NSData *serviceData = [self executeServiceNegotiationRequestUsingAuthenticator:authenticator AndReturnError:error];
	
	if (serviceData && [serviceNegotiator parseBestMatchingServiceResultWithData:serviceData]) {
		if (serviceNegotiator.bestMatchingServiceUrl && serviceNegotiator.bestMatchingServiceUrl.length > 0) {
			LOGNOTICE(@"Service negotiation process completed successfully. Updating service document URL.");
			self.serviceDocumentURL = serviceNegotiator.bestMatchingServiceUrl;
            // Make sure the service negotiation process runs only once.
            self.useServiceNegotiation = NO;
            return YES;
		}
	}
	return NO;
}

#pragma mark - Batch

- (void)startBatchWithNotificationName:(NSString *)aNotificationName
{
    [self loadCSRFData];
    
    NSDictionary *userInfoDict = nil;
    if ([aNotificationName length] > 0) {
        userInfoDict = @{kBatchCompletedNotification : aNotificationName};
    }
    [connectivityHelper startBatchAsyncWithURL:[[service.serviceDocumentQuery getUrl] absoluteString] andDelegate:self andSelector:@selector(executeBatchCompleted:) andUserInfo:userInfoDict];
}

- (void)closeExistingChangeSet
{
    [connectivityHelper closeExistingChangeSet];
}

- (void)executeBatch
{
    [connectivityHelper executeBatchAsync:csrfData];
}

- (void)executeBatchCompleted:(BatchRequest *)batchRequest
{
    NSArray *requests = [batchRequest requestArray];
    for (int i = 0; i < [requests count]; i++) {
        if ([requests[i] isKindOfClass:[NSArray class]]) {
            for (Request *request in requests[i]) {
                [self performSelectorOnMainThread:request.didFinishSelector withObject:request waitUntilDone:NO];
            }
        }
        else {
            [self performSelectorOnMainThread:((Request *)requests[i]).didFinishSelector withObject:requests[i] waitUntilDone:NO];
        }
    }
    
    NSDictionary *userInfo = batchRequest.userInfo;
    NSString *notificationName = userInfo[kBatchCompletedNotification];
    if ([notificationName length] > 0) {
        NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:userInfo];
        userInfoDict[kBatchRequest] = batchRequest;
        [[NSNotificationCenter defaultCenter] postNotificationName:notificationName object:self userInfo:userInfoDict];
    }

}

#pragma mark - Instance methods

- (BOOL)isServiceValid
{
    return (service != nil);
}

- (void)setServiceDocumentURL:(NSString *)serviceDocumentURL
{
    _serviceDocumentURL = serviceDocumentURL;
    
    if ([self.serviceDocumentURL length] > 0) {
        [service setServiceDocumentUrl:self.serviceDocumentURL];
    }
}

- (void)setSAPClient:(NSString *)client
{
    _client = client;
    connectivityHelper.sapClient = self.client;
}

- (void)loadCSRFData
{
    if (!csrfData ) {
        csrfData  = [connectivityHelper getCSRFDataForServiceQuery:service.serviceDocumentQuery];
    }
}




#pragma mark - ReservationService methods
#pragma mark Read

- (void)loadReservationServiceCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getReservationServiceWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadReservationServiceCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadReservationService
{
    ODataQuery *query = service.ReservationServiceQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadReservationServiceCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadReservationServiceCompleted:) andUserInfo:userInfoDict];
}

- (void)loadIT_ARACLARSetForReservationServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    ReservationService *parentReservationServiceItem = request.userInfo[kResponseParentItem];
    [parentReservationServiceItem loadIT_ARACLARSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReservationServiceItem.IT_ARACLARSet;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadIT_ARACLARSetForReservationServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadIT_ARACLARSetForReservationService:(ReservationService *)aReservationService
{
    ODataQuery *query = aReservationService.IT_ARACLARSetQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReservationService , kRequestUserInfoCompletedNotification : kLoadIT_ARACLARSetForReservationServiceCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadIT_ARACLARSetForReservationServiceCompleted:) andUserInfo:userInfoDict];
}

- (void)loadIT_EKSURUCUSetForReservationServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    ReservationService *parentReservationServiceItem = request.userInfo[kResponseParentItem];
    [parentReservationServiceItem loadIT_EKSURUCUSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReservationServiceItem.IT_EKSURUCUSet;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadIT_EKSURUCUSetForReservationServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadIT_EKSURUCUSetForReservationService:(ReservationService *)aReservationService
{
    ODataQuery *query = aReservationService.IT_EKSURUCUSetQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReservationService , kRequestUserInfoCompletedNotification : kLoadIT_EKSURUCUSetForReservationServiceCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadIT_EKSURUCUSetForReservationServiceCompleted:) andUserInfo:userInfoDict];
}

- (void)loadIT_ITEMSSetForReservationServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    ReservationService *parentReservationServiceItem = request.userInfo[kResponseParentItem];
    [parentReservationServiceItem loadIT_ITEMSSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReservationServiceItem.IT_ITEMSSet;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadIT_ITEMSSetForReservationServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadIT_ITEMSSetForReservationService:(ReservationService *)aReservationService
{
    ODataQuery *query = aReservationService.IT_ITEMSSetQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReservationService , kRequestUserInfoCompletedNotification : kLoadIT_ITEMSSetForReservationServiceCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadIT_ITEMSSetForReservationServiceCompleted:) andUserInfo:userInfoDict];
}

- (void)loadIT_FATURA_ADRESSetForReservationServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    ReservationService *parentReservationServiceItem = request.userInfo[kResponseParentItem];
    [parentReservationServiceItem loadIT_FATURA_ADRESSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReservationServiceItem.IT_FATURA_ADRESSet;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadIT_FATURA_ADRESSetForReservationServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadIT_FATURA_ADRESSetForReservationService:(ReservationService *)aReservationService
{
    ODataQuery *query = aReservationService.IT_FATURA_ADRESSetQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReservationService , kRequestUserInfoCompletedNotification : kLoadIT_FATURA_ADRESSetForReservationServiceCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadIT_FATURA_ADRESSetForReservationServiceCompleted:) andUserInfo:userInfoDict];
}

- (void)loadET_RETURNSetForReservationServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    ReservationService *parentReservationServiceItem = request.userInfo[kResponseParentItem];
    [parentReservationServiceItem loadET_RETURNSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReservationServiceItem.ET_RETURNSet;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_RETURNSetForReservationServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadET_RETURNSetForReservationService:(ReservationService *)aReservationService
{
    ODataQuery *query = aReservationService.ET_RETURNSetQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReservationService , kRequestUserInfoCompletedNotification : kLoadET_RETURNSetForReservationServiceCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_RETURNSetForReservationServiceCompleted:) andUserInfo:userInfoDict];
}

- (void)loadIT_TAHSILATSetForReservationServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    ReservationService *parentReservationServiceItem = request.userInfo[kResponseParentItem];
    [parentReservationServiceItem loadIT_TAHSILATSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReservationServiceItem.IT_TAHSILATSet;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadIT_TAHSILATSetForReservationServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadIT_TAHSILATSetForReservationService:(ReservationService *)aReservationService
{
    ODataQuery *query = aReservationService.IT_TAHSILATSetQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReservationService , kRequestUserInfoCompletedNotification : kLoadIT_TAHSILATSetForReservationServiceCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadIT_TAHSILATSetForReservationServiceCompleted:) andUserInfo:userInfoDict];
}

- (void)loadIT_SDREZERVSetForReservationServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSError *error;
    ReservationService *parentReservationServiceItem = request.userInfo[kResponseParentItem];
    [parentReservationServiceItem loadIT_SDREZERVSetWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict[kParsingError] = error;
    }
    else {
    	userInfoDict[kResponseItems] = parentReservationServiceItem.IT_SDREZERVSet;
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadIT_SDREZERVSetForReservationServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)loadIT_SDREZERVSetForReservationService:(ReservationService *)aReservationService
{
    ODataQuery *query = aReservationService.IT_SDREZERVSetQuery;
    NSDictionary *userInfoDict = @{kResponseParentItem : aReservationService , kRequestUserInfoCompletedNotification : kLoadIT_SDREZERVSetForReservationServiceCompletedNotification}; 
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadIT_SDREZERVSetForReservationServiceCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createReservationServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ReservationService *item = [ReservationService parseReservationServiceEntryWithData:responseData error:&error];
        NSMutableArray *expands= [ReservationServiceV0 parseExpandedReservationServiceEntriesWithData:responseData andServiceDocument:service.sdmServiceDocument error:&error];
        item = [expands objectAtIndex:0];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReservationServiceCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createReservationService:(ReservationService *)aReservationService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aReservationService error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aReservationService error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateReservationServiceCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aReservationService , kRequestUserInfoCompletedNotification : kCreateReservationServiceCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.ReservationServiceQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createReservationServiceCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createIT_ARACLAR:(IT_ARACLAR *)aNewIT_ARACLAR forReservationService:(ReservationService *)aReservationService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewIT_ARACLAR error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewIT_ARACLAR error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_ARACLARCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewIT_ARACLAR , kRequestUserInfoCompletedNotification : kCreateIT_ARACLARCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReservationService.IT_ARACLARSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createIT_ARACLARCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createIT_EKSURUCU:(IT_EKSURUCU *)aNewIT_EKSURUCU forReservationService:(ReservationService *)aReservationService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewIT_EKSURUCU error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewIT_EKSURUCU error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_EKSURUCUCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewIT_EKSURUCU , kRequestUserInfoCompletedNotification : kCreateIT_EKSURUCUCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReservationService.IT_EKSURUCUSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createIT_EKSURUCUCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createIT_ITEMS:(IT_ITEMS *)aNewIT_ITEMS forReservationService:(ReservationService *)aReservationService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewIT_ITEMS error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewIT_ITEMS error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_ITEMSCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewIT_ITEMS , kRequestUserInfoCompletedNotification : kCreateIT_ITEMSCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReservationService.IT_ITEMSSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createIT_ITEMSCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createIT_FATURA_ADRES:(IT_FATURA_ADRES *)aNewIT_FATURA_ADRES forReservationService:(ReservationService *)aReservationService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewIT_FATURA_ADRES error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewIT_FATURA_ADRES error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_FATURA_ADRESCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewIT_FATURA_ADRES , kRequestUserInfoCompletedNotification : kCreateIT_FATURA_ADRESCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReservationService.IT_FATURA_ADRESSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createIT_FATURA_ADRESCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createET_RETURN:(ET_RETURN *)aNewET_RETURN forReservationService:(ReservationService *)aReservationService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewET_RETURN error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewET_RETURN error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_RETURNCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewET_RETURN , kRequestUserInfoCompletedNotification : kCreateET_RETURNCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReservationService.ET_RETURNSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createET_RETURNCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createIT_TAHSILAT:(IT_TAHSILAT *)aNewIT_TAHSILAT forReservationService:(ReservationService *)aReservationService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewIT_TAHSILAT error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewIT_TAHSILAT error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_TAHSILATCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewIT_TAHSILAT , kRequestUserInfoCompletedNotification : kCreateIT_TAHSILATCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReservationService.IT_TAHSILATSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createIT_TAHSILATCompleted:) andUserInfo:userInfoDict];
    }
}

- (void)createIT_SDREZERV:(IT_SDREZERV *)aNewIT_SDREZERV forReservationService:(ReservationService *)aReservationService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aNewIT_SDREZERV error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aNewIT_SDREZERV error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_SDREZERVCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aNewIT_SDREZERV , kRequestUserInfoCompletedNotification : kCreateIT_SDREZERVCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:aReservationService.IT_SDREZERVSetQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createIT_SDREZERVCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateReservationServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ReservationService *item = [ReservationService parseReservationServiceEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReservationServiceCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateReservationService:(ReservationService *)aReservationService
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aReservationService error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aReservationService error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateReservationServiceCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aReservationService.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aReservationService , kRequestUserInfoCompletedNotification : kUpdateReservationServiceCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateReservationServiceCompleted:) andUserInfo:userInfoDict andEtag:aReservationService.etag];
    }
}

#pragma mark Delete

- (void)deleteReservationServiceCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteReservationServiceCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteReservationService:(ReservationService *)aReservationService 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aReservationService.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aReservationService , kRequestUserInfoCompletedNotification : kDeleteReservationServiceCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteReservationServiceCompleted:) andUserInfo:userInfoDict andEtag:aReservationService.etag];
}

#pragma mark - ET_KK_RETURN methods
#pragma mark Read

- (void)loadET_KK_RETURNCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getET_KK_RETURNWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_KK_RETURNCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadET_KK_RETURN
{
    ODataQuery *query = service.ET_KK_RETURNQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadET_KK_RETURNCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_KK_RETURNCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createET_KK_RETURNCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_KK_RETURN *item = [ET_KK_RETURN parseET_KK_RETURNEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_KK_RETURNCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createET_KK_RETURN:(ET_KK_RETURN *)aET_KK_RETURN
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aET_KK_RETURN error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aET_KK_RETURN error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_KK_RETURNCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aET_KK_RETURN , kRequestUserInfoCompletedNotification : kCreateET_KK_RETURNCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.ET_KK_RETURNQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createET_KK_RETURNCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateET_KK_RETURNCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_KK_RETURN *item = [ET_KK_RETURN parseET_KK_RETURNEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_KK_RETURNCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateET_KK_RETURN:(ET_KK_RETURN *)aET_KK_RETURN
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aET_KK_RETURN error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aET_KK_RETURN error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_KK_RETURNCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_KK_RETURN.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aET_KK_RETURN , kRequestUserInfoCompletedNotification : kUpdateET_KK_RETURNCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateET_KK_RETURNCompleted:) andUserInfo:userInfoDict andEtag:aET_KK_RETURN.etag];
    }
}

#pragma mark Delete

- (void)deleteET_KK_RETURNCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteET_KK_RETURNCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteET_KK_RETURN:(ET_KK_RETURN *)aET_KK_RETURN 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_KK_RETURN.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aET_KK_RETURN , kRequestUserInfoCompletedNotification : kDeleteET_KK_RETURNCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteET_KK_RETURNCompleted:) andUserInfo:userInfoDict andEtag:aET_KK_RETURN.etag];
}

#pragma mark - ET_RETURN methods
#pragma mark Read

- (void)loadET_RETURNCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getET_RETURNWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadET_RETURNCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadET_RETURN
{
    ODataQuery *query = service.ET_RETURNQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadET_RETURNCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadET_RETURNCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createET_RETURNCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_RETURN *item = [ET_RETURN parseET_RETURNEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_RETURNCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createET_RETURN:(ET_RETURN *)aET_RETURN
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aET_RETURN error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aET_RETURN error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateET_RETURNCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aET_RETURN , kRequestUserInfoCompletedNotification : kCreateET_RETURNCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.ET_RETURNQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createET_RETURNCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateET_RETURNCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        ET_RETURN *item = [ET_RETURN parseET_RETURNEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_RETURNCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateET_RETURN:(ET_RETURN *)aET_RETURN
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aET_RETURN error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aET_RETURN error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateET_RETURNCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_RETURN.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aET_RETURN , kRequestUserInfoCompletedNotification : kUpdateET_RETURNCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateET_RETURNCompleted:) andUserInfo:userInfoDict andEtag:aET_RETURN.etag];
    }
}

#pragma mark Delete

- (void)deleteET_RETURNCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteET_RETURNCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteET_RETURN:(ET_RETURN *)aET_RETURN 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aET_RETURN.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aET_RETURN , kRequestUserInfoCompletedNotification : kDeleteET_RETURNCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteET_RETURNCompleted:) andUserInfo:userInfoDict andEtag:aET_RETURN.etag];
}

#pragma mark - IT_ARACLAR methods
#pragma mark Read

- (void)loadIT_ARACLARCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getIT_ARACLARWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadIT_ARACLARCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadIT_ARACLAR
{
    ODataQuery *query = service.IT_ARACLARQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadIT_ARACLARCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadIT_ARACLARCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createIT_ARACLARCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        IT_ARACLAR *item = [IT_ARACLAR parseIT_ARACLAREntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_ARACLARCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createIT_ARACLAR:(IT_ARACLAR *)aIT_ARACLAR
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aIT_ARACLAR error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aIT_ARACLAR error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_ARACLARCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aIT_ARACLAR , kRequestUserInfoCompletedNotification : kCreateIT_ARACLARCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.IT_ARACLARQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createIT_ARACLARCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateIT_ARACLARCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        IT_ARACLAR *item = [IT_ARACLAR parseIT_ARACLAREntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateIT_ARACLARCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateIT_ARACLAR:(IT_ARACLAR *)aIT_ARACLAR
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aIT_ARACLAR error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aIT_ARACLAR error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateIT_ARACLARCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aIT_ARACLAR.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aIT_ARACLAR , kRequestUserInfoCompletedNotification : kUpdateIT_ARACLARCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateIT_ARACLARCompleted:) andUserInfo:userInfoDict andEtag:aIT_ARACLAR.etag];
    }
}

#pragma mark Delete

- (void)deleteIT_ARACLARCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteIT_ARACLARCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteIT_ARACLAR:(IT_ARACLAR *)aIT_ARACLAR 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aIT_ARACLAR.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aIT_ARACLAR , kRequestUserInfoCompletedNotification : kDeleteIT_ARACLARCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteIT_ARACLARCompleted:) andUserInfo:userInfoDict andEtag:aIT_ARACLAR.etag];
}

#pragma mark - IT_EKSURUCU methods
#pragma mark Read

- (void)loadIT_EKSURUCUCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getIT_EKSURUCUWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadIT_EKSURUCUCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadIT_EKSURUCU
{
    ODataQuery *query = service.IT_EKSURUCUQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadIT_EKSURUCUCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadIT_EKSURUCUCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createIT_EKSURUCUCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        IT_EKSURUCU *item = [IT_EKSURUCU parseIT_EKSURUCUEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_EKSURUCUCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createIT_EKSURUCU:(IT_EKSURUCU *)aIT_EKSURUCU
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aIT_EKSURUCU error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aIT_EKSURUCU error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_EKSURUCUCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aIT_EKSURUCU , kRequestUserInfoCompletedNotification : kCreateIT_EKSURUCUCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.IT_EKSURUCUQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createIT_EKSURUCUCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateIT_EKSURUCUCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        IT_EKSURUCU *item = [IT_EKSURUCU parseIT_EKSURUCUEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateIT_EKSURUCUCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateIT_EKSURUCU:(IT_EKSURUCU *)aIT_EKSURUCU
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aIT_EKSURUCU error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aIT_EKSURUCU error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateIT_EKSURUCUCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aIT_EKSURUCU.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aIT_EKSURUCU , kRequestUserInfoCompletedNotification : kUpdateIT_EKSURUCUCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateIT_EKSURUCUCompleted:) andUserInfo:userInfoDict andEtag:aIT_EKSURUCU.etag];
    }
}

#pragma mark Delete

- (void)deleteIT_EKSURUCUCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteIT_EKSURUCUCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteIT_EKSURUCU:(IT_EKSURUCU *)aIT_EKSURUCU 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aIT_EKSURUCU.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aIT_EKSURUCU , kRequestUserInfoCompletedNotification : kDeleteIT_EKSURUCUCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteIT_EKSURUCUCompleted:) andUserInfo:userInfoDict andEtag:aIT_EKSURUCU.etag];
}

#pragma mark - IT_FATURA_ADRES methods
#pragma mark Read

- (void)loadIT_FATURA_ADRESCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getIT_FATURA_ADRESWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadIT_FATURA_ADRESCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadIT_FATURA_ADRES
{
    ODataQuery *query = service.IT_FATURA_ADRESQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadIT_FATURA_ADRESCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadIT_FATURA_ADRESCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createIT_FATURA_ADRESCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        IT_FATURA_ADRES *item = [IT_FATURA_ADRES parseIT_FATURA_ADRESEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_FATURA_ADRESCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createIT_FATURA_ADRES:(IT_FATURA_ADRES *)aIT_FATURA_ADRES
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aIT_FATURA_ADRES error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aIT_FATURA_ADRES error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_FATURA_ADRESCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aIT_FATURA_ADRES , kRequestUserInfoCompletedNotification : kCreateIT_FATURA_ADRESCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.IT_FATURA_ADRESQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createIT_FATURA_ADRESCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateIT_FATURA_ADRESCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        IT_FATURA_ADRES *item = [IT_FATURA_ADRES parseIT_FATURA_ADRESEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateIT_FATURA_ADRESCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateIT_FATURA_ADRES:(IT_FATURA_ADRES *)aIT_FATURA_ADRES
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aIT_FATURA_ADRES error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aIT_FATURA_ADRES error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateIT_FATURA_ADRESCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aIT_FATURA_ADRES.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aIT_FATURA_ADRES , kRequestUserInfoCompletedNotification : kUpdateIT_FATURA_ADRESCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateIT_FATURA_ADRESCompleted:) andUserInfo:userInfoDict andEtag:aIT_FATURA_ADRES.etag];
    }
}

#pragma mark Delete

- (void)deleteIT_FATURA_ADRESCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteIT_FATURA_ADRESCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteIT_FATURA_ADRES:(IT_FATURA_ADRES *)aIT_FATURA_ADRES 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aIT_FATURA_ADRES.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aIT_FATURA_ADRES , kRequestUserInfoCompletedNotification : kDeleteIT_FATURA_ADRESCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteIT_FATURA_ADRESCompleted:) andUserInfo:userInfoDict andEtag:aIT_FATURA_ADRES.etag];
}

#pragma mark - IT_ITEMS methods
#pragma mark Read

- (void)loadIT_ITEMSCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getIT_ITEMSWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadIT_ITEMSCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadIT_ITEMS
{
    ODataQuery *query = service.IT_ITEMSQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadIT_ITEMSCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadIT_ITEMSCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createIT_ITEMSCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        IT_ITEMS *item = [IT_ITEMS parseIT_ITEMSEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_ITEMSCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createIT_ITEMS:(IT_ITEMS *)aIT_ITEMS
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aIT_ITEMS error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aIT_ITEMS error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_ITEMSCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aIT_ITEMS , kRequestUserInfoCompletedNotification : kCreateIT_ITEMSCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.IT_ITEMSQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createIT_ITEMSCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateIT_ITEMSCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        IT_ITEMS *item = [IT_ITEMS parseIT_ITEMSEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateIT_ITEMSCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateIT_ITEMS:(IT_ITEMS *)aIT_ITEMS
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aIT_ITEMS error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aIT_ITEMS error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateIT_ITEMSCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aIT_ITEMS.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aIT_ITEMS , kRequestUserInfoCompletedNotification : kUpdateIT_ITEMSCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateIT_ITEMSCompleted:) andUserInfo:userInfoDict andEtag:aIT_ITEMS.etag];
    }
}

#pragma mark Delete

- (void)deleteIT_ITEMSCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteIT_ITEMSCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteIT_ITEMS:(IT_ITEMS *)aIT_ITEMS 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aIT_ITEMS.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aIT_ITEMS , kRequestUserInfoCompletedNotification : kDeleteIT_ITEMSCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteIT_ITEMSCompleted:) andUserInfo:userInfoDict andEtag:aIT_ITEMS.etag];
}

#pragma mark - IT_SDREZERV methods
#pragma mark Read

- (void)loadIT_SDREZERVCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getIT_SDREZERVWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadIT_SDREZERVCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadIT_SDREZERV
{
    ODataQuery *query = service.IT_SDREZERVQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadIT_SDREZERVCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadIT_SDREZERVCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createIT_SDREZERVCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        IT_SDREZERV *item = [IT_SDREZERV parseIT_SDREZERVEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_SDREZERVCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createIT_SDREZERV:(IT_SDREZERV *)aIT_SDREZERV
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aIT_SDREZERV error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aIT_SDREZERV error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_SDREZERVCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aIT_SDREZERV , kRequestUserInfoCompletedNotification : kCreateIT_SDREZERVCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.IT_SDREZERVQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createIT_SDREZERVCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateIT_SDREZERVCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        IT_SDREZERV *item = [IT_SDREZERV parseIT_SDREZERVEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateIT_SDREZERVCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateIT_SDREZERV:(IT_SDREZERV *)aIT_SDREZERV
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aIT_SDREZERV error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aIT_SDREZERV error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateIT_SDREZERVCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aIT_SDREZERV.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aIT_SDREZERV , kRequestUserInfoCompletedNotification : kUpdateIT_SDREZERVCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateIT_SDREZERVCompleted:) andUserInfo:userInfoDict andEtag:aIT_SDREZERV.etag];
    }
}

#pragma mark Delete

- (void)deleteIT_SDREZERVCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteIT_SDREZERVCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteIT_SDREZERV:(IT_SDREZERV *)aIT_SDREZERV 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aIT_SDREZERV.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aIT_SDREZERV , kRequestUserInfoCompletedNotification : kDeleteIT_SDREZERVCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteIT_SDREZERVCompleted:) andUserInfo:userInfoDict andEtag:aIT_SDREZERV.etag];
}

#pragma mark - IT_TAHSILAT methods
#pragma mark Read

- (void)loadIT_TAHSILATCompleted:(id <Requesting>)request
{
    NSDictionary *userInfoDict;
    NSError *error;
    NSMutableArray *items = [service getIT_TAHSILATWithData:request.responseData error:&error];
    if (error) {
    	userInfoDict = @{kParsingError: error};
    }
    else {
    	userInfoDict = @{kResponseItems: items};
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kLoadIT_TAHSILATCompletedNotification object:self userInfo:userInfoDict];
}

- (void)loadIT_TAHSILAT
{
    ODataQuery *query = service.IT_TAHSILATQuery;
    NSDictionary *userInfoDict = @{kRequestUserInfoCompletedNotification : kLoadIT_TAHSILATCompletedNotification};
    [connectivityHelper executeBasicAsyncRequestWithQuery:query andRequestDelegate:self andDidFinishSelector:@selector(loadIT_TAHSILATCompleted:) andUserInfo:userInfoDict];
}

#pragma mark Create

- (void)createIT_TAHSILATCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        IT_TAHSILAT *item = [IT_TAHSILAT parseIT_TAHSILATEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_TAHSILATCompletedNotification object:self userInfo:userInfoDict];

}

- (void)createIT_TAHSILAT:(IT_TAHSILAT *)aIT_TAHSILAT
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForCreateRequest:aIT_TAHSILAT error:&error];
    }
    else {
        payload = [service getXMLForCreateRequest:aIT_TAHSILAT error:&error];
    }
    
	if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kCreateIT_TAHSILATCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        NSDictionary *userInfoDict = @{kResponseParentItem : aIT_TAHSILAT , kRequestUserInfoCompletedNotification : kCreateIT_TAHSILATCompletedNotification};
    	[connectivityHelper executeCreateAsyncRequestWithQuery:service.IT_TAHSILATQuery andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(createIT_TAHSILATCompleted:) andUserInfo:userInfoDict];
    }
}

#pragma mark Update

- (void)updateIT_TAHSILATCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    NSData *responseData = request.responseData;
    if ([responseData length] > 0) {
        NSError *error;
        IT_TAHSILAT *item = [IT_TAHSILAT parseIT_TAHSILATEntryWithData:responseData error:&error];
        if (error) {
        	userInfoDict[kParsingError] = error;
        }
        else{
        	userInfoDict[kResponseItem] = item;
        }
    }
    [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateIT_TAHSILATCompletedNotification object:self userInfo:userInfoDict];

}

- (void)updateIT_TAHSILAT:(IT_TAHSILAT *)aIT_TAHSILAT
{
	[self loadCSRFData];
    NSError *error = nil;
    NSString *payload = nil;
    if (self.useJSON) {
        payload = [service getJSONForUpdateRequest:aIT_TAHSILAT error:&error];
    }
    else {
        payload = [service getXMLForUpdateRequest:aIT_TAHSILAT error:&error];
    }
    
    if (error) {
        NSMutableDictionary *userInfoDict = [@{} mutableCopy];
        userInfoDict[kParsingError] = error;
        [[NSNotificationCenter defaultCenter] postNotificationName:kUpdateIT_TAHSILATCompletedNotification object:self userInfo:userInfoDict];
    }
    else {
        ODataQuery *query = [[ODataQuery alloc] initWithURL:aIT_TAHSILAT.baseUrl];
    	NSDictionary *userInfoDict = @{kResponseParentItem : aIT_TAHSILAT , kRequestUserInfoCompletedNotification : kUpdateIT_TAHSILATCompletedNotification};
    	[connectivityHelper executeUpdateAsyncRequestWithQuery:query andBody:payload andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(updateIT_TAHSILATCompleted:) andUserInfo:userInfoDict andEtag:aIT_TAHSILAT.etag];
    }
}

#pragma mark Delete

- (void)deleteIT_TAHSILATCompleted:(id <Requesting>)request
{
    NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
    [[NSNotificationCenter defaultCenter] postNotificationName:kDeleteIT_TAHSILATCompletedNotification object:self userInfo:userInfoDict];   
}

- (void)deleteIT_TAHSILAT:(IT_TAHSILAT *)aIT_TAHSILAT 
{
	[self loadCSRFData];
    ODataQuery *query = [[ODataQuery alloc] initWithURL:aIT_TAHSILAT.baseUrl];
    NSDictionary *userInfoDict = @{kResponseParentItem : aIT_TAHSILAT , kRequestUserInfoCompletedNotification : kDeleteIT_TAHSILATCompletedNotification};
    [connectivityHelper executeDeleteAsyncRequestWithQuery:query andCSRFData:csrfData andRequestDelegate:self andDidFinishSelector:@selector(deleteIT_TAHSILATCompleted:) andUserInfo:userInfoDict andEtag:aIT_TAHSILAT.etag];
}

#pragma mark - Function Import methods

#pragma mark - RequestDelegate

- (void)requestFailed:(Request *)request
{
    int statusCode = request.responseStatusCode;
    if (statusCode == 401) {
        [self authenticationNeededForRequest:request];
        LOGERROR(@"Request failed with authentication error - response status code 401");
    }
    else {
        NSString *errorMessage;
        NSString *logErrorMessage;
        if (statusCode == 403){
            errorMessage = [request responseString];
            NSString *csrfToken = [request responseHeaders][@"x-csrf-token"];
            if (csrfToken.length > 0 && [csrfToken isEqualToString:@"Required"]) {
            	csrfData = nil;
                NSString *localizedMessage = NSLocalizedString(@"CSRF Token is invalid. Try again to get a new token", @"CSRF Token is invalid. Try again to get a new token");
                errorMessage = [NSString stringWithFormat:@"%@. %@", errorMessage, localizedMessage];
                logErrorMessage = [NSString stringWithFormat:@"Request failed due to invalid CSRF with error: %@. Response status code: %d.", errorMessage, statusCode];
            }
        }
        else {
            errorMessage = request.error ? [request.error localizedDescription] : [request responseStatusMessage];
            logErrorMessage = [NSString stringWithFormat:@"Request failed with error: %@. Response status code: %d.", errorMessage, statusCode];
            
            id<ServiceErrorParsing> serviceErrorParser = nil;
            NSString *contentType = [[[request responseHeaders] objectForKey:@"Content-Type"] lowercaseString];
            if ([contentType isEqualToString:@"application/json"]) {
                serviceErrorParser = [[ServiceErrorJsonParser alloc] initWithErrorData:[request responseData]];
            }
            else {
                serviceErrorParser = [[ServiceErrorXmlParser alloc] initWithErrorData:[request responseData]];
            }
            if ([serviceErrorParser parse]) {
                ServiceError *serviceError = [serviceErrorParser result];
                
                if ([serviceError.innerMessage length] > 0){
                    logErrorMessage = [logErrorMessage stringByAppendingString:[NSString stringWithFormat:@" Service error message: %@ Service error inner message: %@", serviceError.message, serviceError.innerMessage]];
                }
                else{
                    logErrorMessage = [logErrorMessage stringByAppendingString:[NSString stringWithFormat:@" Service response: %@", serviceError.message]];
                }
                
                errorMessage = serviceError.message;
            }
            else
            {
                logErrorMessage = [logErrorMessage stringByAppendingString:[NSString stringWithFormat:@" Response body: %@",[request responseString]]];
            }
        }
        LOGERROR(logErrorMessage);
        
        NSMutableDictionary *errorUserInfoDict = [@{} mutableCopy];
        errorUserInfoDict[NSLocalizedDescriptionKey] = errorMessage;
        NSError *error = [NSError errorWithDomain:ERROR_DOMAIN code:REQUEST_FAILED_ERROR_CODE userInfo:errorUserInfoDict];
        
        NSMutableDictionary *userInfoDict = [NSMutableDictionary dictionaryWithDictionary:request.userInfo];
        userInfoDict[kServerResponseError] = error;
        
        // Send error notification (handled by all the application views)
        [[NSNotificationCenter defaultCenter] postNotificationName:request.userInfo[kRequestUserInfoCompletedNotification] object:self userInfo:userInfoDict];
    }
}


- (void)authenticationNeededForRequest:(Request *)request
{
    //Cancel request and send notification for displaying the login screen
    [request cancelAuthentication];
    [[NSNotificationCenter defaultCenter] postNotificationName:kAuthenticationNeededNotification object:self userInfo:nil];
}

#pragma mark - SDMConnectivityHelperDelegate

- (void)onBeforeSend:(id <Requesting>)request
{
	request.shouldPresentAuthenticationDialog = YES;
    
    [request setTimeOutSeconds:[ApplicationProperties getTimeout]];
    [request setUsername:[ApplicationProperties getSAPUser]];
    [request setPassword:[ApplicationProperties getSAPPassword]];
    if ([ConnectivitySettings isSUPMode]) {
        if ([KeychainHelper isCredentialsSaved]){
            NSError *error = nil;
            CredentialsData *credentials = [KeychainHelper loadCredentialsAndReturnError:&error];
            if (credentials) {

            }
            else if(error) {
                NSString *msg = [error localizedDescription];
                LOGERROR(msg);
            }
            else {
                NSString *msg = NSLocalizedString(@"Error while loading credentials from keychain", @"Error while loading credentials from keychain");
                LOGERROR(msg);
            }
        }
    }
    else if ([ConnectivitySettings authenticationType] == CertificateAuthenticationType) {
        [request setClientCertificateIdentity:certificate];
    }

    //Define the request language as the device language settings. Uncomment the following line to use the user default language as defined on the server.
    [request addRequestHeader:@"sap-language" value:deviceLanguage];
        
    if (self.useJSON) {
        NSString *jsonUrl = [request.url absoluteString];
        // Don't use jSON to fetch metadata or service document
        if ([self isJSONAllowedForUrl:jsonUrl]) {
            [request addRequestHeader:@"Content-Type" value:@"application/json"];
            [request addRequestHeader:@"Accept" value:@"application/json"];
        }
    }
}

- (BOOL)isJSONAllowedForUrl:(NSString *)jsonUrl
{
    if ([jsonUrl rangeOfString:@"$metadata" options:NSCaseInsensitiveSearch].location == NSNotFound) {
        if (![self.serviceDocumentURL isEqualToString:jsonUrl]) {
            return YES;
        }
    }
    
    return NO;
}

@end
